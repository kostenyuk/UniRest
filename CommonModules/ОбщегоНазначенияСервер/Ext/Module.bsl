 ////////////////////////////////////////////////////////////////////////////////
 // Клиентские и серверные процедуры общего назначения
 // ОбщегоНазначенияСервер.                                                       
 Функция  ПолучитьПустуюДату() Экспорт		
	 Возврат '00010101000000';
 КонецФункции
 
 // удаление ведущих нулей
 //
 Функция УдалениеВедущихНулей(Знач Номер) Экспорт 
	 
	 Пока Лев(Номер, 1)="0" Цикл
		 Номер = Сред(Номер, 2);	
	 КонецЦикла;
	 Возврат Номер;
	 
 КонецФункции
 
 Функция РазложитьЧислоВСтроку(Значение, Длина, ЛидирующиеНули=Ложь) Экспорт
	
	ФорматнаяСтрока = "ЧЦ="+Строка(Длина)+"; ЧДЦ=0; ЧГ=0";
	Если ЛидирующиеНули Тогда
		Строка0 = "0";
		Для Сч = 2 по Длина Цикл
			Строка0 = Строка0+"0";
		Конеццикла;
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН="+Строка0+"; ЧВН=";
	Иначе
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН=0";
	КонецЕсли;
	
	Результат = Формат(Значение,ФорматнаяСтрока);
	
	Если НЕ ЛидирующиеНули Тогда
		
		Пока СтрДлина(Результат) < Длина Цикл
			Результат = " "+Результат;
		КонецЦикла;	
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

 //Тоже что и ЗначениеЗаполнено только для Новый ()
 //
 Функция ЗначениеЗаполненоДляОбъектов(Значение) Экспорт
	 
	 Если ТипЗнч(Значение) = тип("УникальныйИдентификатор") Тогда
		 СтрокаGUID = "00000000-0000-0000-0000-000000000000"; 
		 Возврат Значение = Новый УникальныйИдентификатор(СтрокаGUID); 		 
	 КонецЕсли;	 
		 Возврат Значение = Новый(ТипЗнч(Значение));
	           
 КонецФункции
 
 
 // Дополняет таблицу значений Таблица значениями из массива Массив.
 //
 // Параметры:
 //  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива
 //  Массив - Массив - массив значений для заполнения таблицы
 //  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива
 // 
 Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт
	 
	 Для каждого Значение Из Массив Цикл
		 
		 Таблица.Добавить()[ИмяПоля] = Значение;
		 
	 КонецЦикла;
	 
 КонецПроцедуры
 
 // Снимает один элемент условного оформления, если это список значений.
 // Параметры
 // УсловноеОформление - условное оформление элемента формы
 // ИдентификаторПользовательскойНастройки - строка - идентификатор настройки
 // Значение - значение, которое требуется удалить из списка оформления
 //
 Процедура СнятьУсловноеОформлениеСпискаЗначений(
	 УсловноеОформление,
	 знач ИдентификаторПользовательскойНастройки,
	 знач Значение) Экспорт
	 
	 Для каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		 Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			 Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				 Возврат;
			 КонецЕсли;
			 ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			 Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				 Возврат;
			 КонецЕсли;
			 ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			 Если ЭлементСписка <> Неопределено Тогда
				 ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			 КонецЕсли;
			 ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			 Возврат;
		 КонецЕсли;
	 КонецЦикла;
	 
 КонецПроцедуры
 
 // Удаляет одно значение из массива
 //
 // Параметры:
 //  Массив - массив, из которого необходимо удалить значение
 //  Значение - удаляемое значение из массива
 // 
 Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	 
	 Индекс = Массив.Найти(Значение);
	 
	 Если Индекс <> Неопределено Тогда
		 
		 Массив.Удалить(Индекс);
		 
	 КонецЕсли;
	 
 КонецПроцедуры
 
 // Заполняет коллекцию-приемник значениями из коллекции-источник
 // В качестве коллекций источника и приемника могут выступать типы:
 // ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
 //
 // Параметры:
 //  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных
 //  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных
 // 
 Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	 
	 Для Каждого Элемент ИЗ КоллекцияИсточник Цикл
		 
		 ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		 
	 КонецЦикла;
	 
 КонецПроцедуры
 
 // Получает массив значений из отмеченных элементов списка значений
 //
 // Параметры:
 //  Список - СписокЗначений - список значений из которого будет формироваться массив значений
 // 
 // Возвращаемое значение:
 //  Массив - массив значений из отмеченных элементов списка значений
 //
 Функция ПолучитьМассивОтмеченныхЭлементовСписка(Список) Экспорт
	 
	 // возвращаемое значение функции
	 Массив = Новый Массив;
	 
	 Для Каждого Элемент ИЗ Список Цикл
		 
		 Если Элемент.Пометка Тогда
			 
			 Массив.Добавить(Элемент.Значение);
			 
		 КонецЕсли;
		 
	 КонецЦикла;
	 
	 Возврат Массив;
 КонецФункции

 
 ////////////////////////////////////////////////////////////////////////////////
 // Блок функций для работы с файловой системой
 //
 
 // Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
 //
 // Параметры:
 //  Путь         - Строка, полный путь каталога, в котором требуется
 //                 удалить все файлы.
 //
 Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	 
	 Каталог = Новый Файл(Путь);
	 
	 Если Каталог.Существует() Тогда
		 УдалитьФайлы(Путь);
	 КонецЕсли;
	 
 КонецПроцедуры // УдалитьКаталогСФайлами()
 
 // Добавляет к переданному пути каталога конечный символ-разделитель,
 // если необходимо.
 //
 // Параметры
 //  ПутьКаталога  - Строка - путь к каталогу
 //
 // Возвращаемое значение:
 //   Строка   - путь к каталогу с конечным символом-разделителем.
 //
 // Примеры использования:
 //    Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
 //    Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
 //    Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
 //
 Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога) Экспорт
	 Если ПустаяСтрока(ПутьКаталога) Тогда
		 Возврат ПутьКаталога;
	 КонецЕсли;
	 
	 ДобавляемыйСимвол = "\";
	 Если Найти(ПутьКаталога, "/") > 0 Тогда
		 ДобавляемыйСимвол = "/";
	 КонецЕсли;
	 
	 Длина = СтрДлина(ПутьКаталога);
	 Если Длина = 0 Тогда
		 Возврат ДобавляемыйСимвол;
	 ИначеЕсли Сред(ПутьКаталога, Длина, 1) <> ДобавляемыйСимвол Тогда
		 Возврат ПутьКаталога + ДобавляемыйСимвол;
	 Иначе 
		 Возврат ПутьКаталога;
	 КонецЕсли;
 КонецФункции
 
 // Составляет полное имя файла из имени каталога и имени файла.
 //
 // Параметры
 //  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
 //  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
 //
 // Возвращаемое значение:
 //   Строка – полное имя файла с учетом каталога.
 //
 Функция ПолучитьИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт
	 
	 Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		 
		 Слэш = "";
		 Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			 Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		 КонецЕсли;
		 
		 Возврат ИмяКаталога + Слэш + ИмяФайла;
		 
	 Иначе
		 
		 Возврат ИмяКаталога;
		 
	 КонецЕсли;
	 
 КонецФункции
 
 ////////////////////////////////////////////////////////////////////////////////
 // Блок функций для работы с почтовыми адресами
 //
 
 // Функция проверяет что введенная строка с e-mail адресами введена правильно
 //
 // Формат строки:
 // Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
 // 
 //   прим.: разделитель* - имеется в виду любой разделитель адресов
 //
 // Параметры:
 // СтрокаАдресов - строка - правильная строка с почтовыми адресами
 //
 // Возвращаемое значение:
 // Структура
 // ключ Статус - булево - успех или неуспех преобразования
 // в случае успеха содержит ключ Значение:
 //           Массив структур, где
 //                  Адрес- e-mail получателя
 //                  Представление   - имя получателя
 // в случае неуспеха содержит ключ СообщениеОбОшибке - строка
 //
 //  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
 //         может быть незаполнено. Может использоваться различными
 //         подсистемами для собственного сопоставления имени пользователя
 //         некому e-mail адресу. Поэтому, необходимо перед непосредственной
 //         отправкой проверить, что поле почтового адреса заполнено.
 //
 Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаАдресов) Экспорт
	 
	 Результат = Новый Массив;
	 
	 НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	 СимволыРазделители = ";,";
	 
	 Индекс = 1;               // номер обрабатываемого символа
	 Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
	 // либо в почтовый адрес
	 ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
	 ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
	 // 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
	 // 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
	 // 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
	 СтадияРазбора = 1; 
	 
	 СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимые символы в почтовом адресе.'");
	 СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Неверный формат почтового адреса.'");
	 
	 Пока Индекс <= СтрДлина(СтрокаАдресов) Цикл
		 
		 Символ = Сред(СтрокаАдресов, Индекс, 1);
		 
		 Если      Символ = " " Тогда
			 Индекс = ? ((ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1) > Индекс,
			 ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1,
			 Индекс);
			 Если      СтадияРазбора = 1 Тогда
				 ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
			 ИначеЕсли СтадияРазбора = 2 Тогда
				 ПочтовыйАдрес = Накопитель;
				 СтадияРазбора = 3;
			 КонецЕсли;
			 Накопитель = "";
		 ИначеЕсли Символ = "@" Тогда
			 Если      СтадияРазбора = 1 Тогда
				 СтадияРазбора = 2;
				 
				 Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
					 Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 Тогда
						 ВызватьИсключение СообщениеНедопустимыеСимволы;
					 КонецЕсли;
				 КонецЦикла;
				 
				 Накопитель = Накопитель + Символ;
			 ИначеЕсли СтадияРазбора = 2 Тогда
				 ВызватьИсключение СообщениеНеверныйФорматПочтовогоАдреса;
			 ИначеЕсли СтадияРазбора = 3 Тогда
				 ВызватьИсключение СообщениеНеверныйФорматПочтовогоАдреса;
			 КонецЕсли;
		 ИначеЕсли Найти(СимволыРазделители, Символ) > 0 Тогда
			 
			 Если      СтадияРазбора = 1 Тогда
				 ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
			 ИначеЕсли СтадияРазбора = 2 Тогда
				 ПочтовыйАдрес = Накопитель;
			 КонецЕсли;
			 
			 СтадияРазбора = 1;
			 
			 Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
				 Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
			 КонецЕсли;
			 
			 ПочтовыйАдрес = "";
			 ПолноеИмяАдресата = "";
			 Накопитель = "";
		 Иначе
			 Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
				 Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
					 ВызватьИсключение СообщениеНедопустимыеСимволы;
				 КонецЕсли;
			 КонецЕсли;
			 
			 Накопитель = Накопитель + Символ;
		 КонецЕсли;
		 
		 Индекс = Индекс + 1;
	 КонецЦикла;
	 
	 Если      СтадияРазбора = 1 Тогда
		 ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
	 ИначеЕсли СтадияРазбора = 2 Тогда
		 ПочтовыйАдрес = Накопитель;
	 КонецЕсли;
	 
	 Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
		 Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
	 КонецЕсли;
	 
	 Возврат Результат;
	 
 КонецФункции
 
 // Проверяет, что почтовый адрес не содержит символов обрамления
 // если символы обрамления вставлены правильно убирает их
 // Параметры:
 //  ПолноеИмяАдресата - строка - имя получателя
 //  ПочтовыйАдрес     - строка - email адрес
 // Возвращаемое значение:
 //  Структура:
 //   Ключ статус - булево - успех или неуспех операции
 //   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
 //   Значение - структура - в случае успеха операции содержит записанную структуру почтового
 //                          адреса: ключи - Адрес, Представление (строки)
 //
 Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	 
	 НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	 НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	 СимволыОбрамления = "<>[]";
	 ДопустимыеСимволыEMAIL = "abcdefghijklmnopqrstuvwxyz0123456789-_.@";
	 
	 ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	 ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	 
	 Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		 Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			 ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		 Иначе
			 ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		 КонецЕсли;
	 ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		 Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			 ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		 Иначе
			 ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		 КонецЕсли;
	 КонецЕсли;
	 
	 Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		 Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			 ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		 Иначе
			 ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		 КонецЕсли;
	 ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		 Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			 ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		 Иначе
			 ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		 КонецЕсли;
	 КонецЕсли;
	 
	 Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		 Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
			 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			 ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		 КонецЕсли;
	 КонецЦикла;
	 
	 Если НЕ ВыполнитьПоискИсключенийВхожденияСимволов(ПочтовыйАдрес, ДопустимыеСимволыEMAIL) Тогда
		 ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
	 КонецЕсли;
	 
	 Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	 
 КонецФункции
 
 Функция ВыполнитьПоискИсключенийВхожденияСимволов(ОбследуемаяСтрока, ДопустимыеСимволы)
	 
	 Для Индекс = 1 По СтрДлина(ОбследуемаяСтрока) Цикл
		 Символ = Сред(ОбследуемаяСтрока, Индекс, 1);
		 
		 Если Найти(ДопустимыеСимволы, НРег(Символ)) = 0 Тогда
			 Возврат Ложь;
		 КонецЕсли;
		 
	 КонецЦикла;
	 
	 Возврат Истина;
	 
 КонецФункции
 
 // Формирует структуру с ключами Статус (Истина) и Значение
 //
 Функция ЗаполнитьРезультат(знач Значение, знач Статус = Истина) Экспорт
	 
	 Если Статус Тогда
		 Возврат Новый Структура("Статус, Значение", Истина, Значение);
	 Иначе
		 Возврат Новый Структура("Статус, СообщениеОбОшибке", Ложь, Значение);
	 КонецЕсли;
	 
 КонецФункции
 
 // Сдвигает маркер позиции пока встречается символ Символ
 // возвращает номер позиции в строке, на которое установился маркер
 //
 Функция ПропуститьПробелы(знач Строка,
	 знач ТекущийИндекс,
	 знач ПропускаемыйСимвол)
	 
	 Результат = ТекущийИндекс;
	 
	 // убираем лишние пробелы если они есть
	 Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		 Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			 Возврат ТекущийИндекс;
		 КонецЕсли;
		 ТекущийИндекс = ТекущийИндекс + 1;
	 КонецЦикла;
	 
	 Возврат ТекущийИндекс;
	 
 КонецФункции
 
 #Если Не ВебКлиент Тогда
 // Функция ПолучитьИмяКаталога возвращает полный путь
 // к новому каталогу в каталоге временных файлов.
 //
 // Параметры:
 //  Идентификатор - Строка, начальная часть имени каталога во временном каталоге.
 //
 // Возвращаемое значение:
 //  Строка - полное имя временного каталога, например "КаталогВременныхФайлов() + Обработка123\".
 // 
 Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	 
	 Индекс = 0;
	 
	 Пока Истина Цикл
		 
		 ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "\";
		 КаталогНаДиске = Новый Файл(ПутьККаталогу);
		 Если НЕ КаталогНаДиске.Существует() Тогда
			 СоздатьКаталог(ПутьККаталогу);
			 Возврат ПутьККаталогу;
		 КонецЕсли;
		 Индекс = Индекс + 1;
		 
	 КонецЦикла;
	 
 КонецФункции // ПолучитьИмяКаталога()
 #КонецЕсли
 
 //Работа С Деревом 
 ///////////////////////////////////////////////////////////////////////////////////////////////
 
 // Процедура выгружает данные из дерева значений в таблицу значений
 // данные выгружаются только в таблицу со сходным набором реквизитов
 //      ОбщегоНазначенияСервер.ВыгрузитьДеревоЗначенийВТаблицуЗначений(Дерево)
 Функция ВыгрузитьДеревоЗначенийВТаблицуЗначений(Дерево, Таблица = Неопределено) Экспорт 
	 Если Таблица = Неопределено Тогда
		 Таблица = Новый ТаблицаЗначений;
		 Для Каждого Колонка Из Дерево.Колонки Цикл Таблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);  КонецЦикла; 
	 КонецЕсли; 
	 Для Каждого СтрокаДерева Из Дерево.Строки Цикл ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СтрокаДерева); ВыгрузитьДеревоЗначенийВТаблицуЗначений(СтрокаДерева, Таблица); КонецЦикла;
	 Возврат Таблица; 
 КонецФункции //ВыгрузитьДеревоЗначенийВТаблицуЗначений()
 
 // Процедура копирует подчиненные строки дерева значений
 //
 Процедура СкопироватьПодчиненныеСтроки(СтрокаПриемник, СтрокаИсточник) Экспорт
	 
	 Для каждого Строка Из СтрокаИсточник.Строки Цикл
		 НоваяСтрока = СтрокаПриемник.Строки.Добавить();
		 //НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
		 ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		 СкопироватьПодчиненныеСтроки(НоваяСтрока, Строка);
	 КонецЦикла;
	 
 КонецПроцедуры // СкопироватьПодчиненныеСтроки()
 
 // Процедура переносит выделенные строки дерева значений в указанную ветку
 //
 Процедура ПеренестиСтрокиДереваЗначений(СтрокаПриемник, ВыделенныеСтроки) Экспорт
	 
	 Если НЕ СтрокаПриемник = Неопределено Тогда
		 МассивСтрок = Новый Массив;
		 Для Каждого СтрокаПереноса Из ВыделенныеСтроки Цикл
			 МассивСтрок.Добавить(СтрокаПереноса);
			 НоваяСтрока = СтрокаПриемник.Строки.Добавить();
			 СкопироватьПодчиненныеСтроки(НоваяСтрока, СтрокаПереноса);
			 ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаПереноса);
			 //НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
		 КонецЦикла;
		 Для Каждого СтрокаДерева Из МассивСтрок Цикл
			 Если СтрокаДерева.Родитель = Неопределено Тогда
				 СтрокаДерева.Строки.Удалить(СтрокаДерева);
			 Иначе
				 СтрокаДерева.Родитель.Строки.Удалить(СтрокаДерева);
			 КонецЕсли;
		 КонецЦикла;
	 КонецЕсли;
	 
 КонецПроцедуры //ПеренестиСтрокиДереваЗначений()
 
 // Процедура выгружает данные из таблицы значений в дерево значений
 // данные выгружаются только в таблицу со сходным набором реквизитов
 // 
 // Параметры:
 // 
 // КлючСтроки - имя колонки ТаблицыЗначений - уникальный идентификатор
 // КлючСвязи - имя колонки ТаблицыЗначений - указатель привязки к строке Дерева,
 // своего рода указатель на "Родителя"
 // 
 Функция ВыгрузитьТаблицуЗначенийВДеревоЗначений(Таблица, КлючСтроки = "", КлючСвязи = "") Экспорт
	 Если ЗначениеЗаполнено(КлючСтроки) И ЗначениеЗаполнено(КлючСвязи) тогда	 
		 Если КлючСвязи = "Родитель" Тогда 
			 Таблица.Колонки.Найти("Родитель").Имя = "РодительDZ"; 
			 КлючСвязи = "РодительDZ"; 
		 КонецЕсли; 
		 Дерево = Новый ДеревоЗначений;
		 Для Каждого Колонка Из Таблица.Колонки Цикл 
			 Дерево.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);  
		 КонецЦикла;
		 Для Каждого СтрокаТаблицы Из Таблица Цикл 
			 СтрокаГруппировки = Дерево.Строки.Найти(СтрокаТаблицы[КлючСвязи], КлючСтроки, Истина); 
			 Если СтрокаГруппировки = Неопределено Тогда  
				 ЗаполнитьЗначенияСвойств(Дерево.Строки.Добавить(), СтрокаТаблицы); 
			 Иначе  ЗаполнитьЗначенияСвойств(СтрокаГруппировки.Строки.Добавить(), СтрокаТаблицы); 
			 КонецЕсли;  
		 КонецЦикла; 
		 Если КлючСвязи = "РодительDZ" Тогда 
			 Дерево.Колонки.Найти("РодительDZ").Имя = "Родитель"; 
			 КлючСвязи = "Родитель";  
		 КонецЕсли;				
		 Возврат Дерево;
	 Иначе 
		 Возврат Неопределено;
	 КонецЕсли;
 КонецФункции //ВыгрузитьТаблицуЗначенийВДеревоЗначений()      
 
 // Получает СТРОКУ значение , содержащееся в 
 // дереве объекта
 //
 // Параметры:
 //  Дерево - дерево значений, содержащее данные объекта
 //  ИскомоеЗначение - имя реквизита, значение которого требуется получить
 //  ИмяКолонки - имя колонки где поиск
 // СтрокаРеквизита найденая строка
 //  
 //
 Процедура  ПолучитьСтрокуИзДерева(Дерево, ИскомоеЗначение, ИмяКолонки, НайденаСтрока = Неопределено , Уровень = Неопределено , Родитель = Неопределено  ) Экспорт
	 
	 СтрокаДерева = Дерево.Строки.Найти(ИскомоеЗначение, ИмяКолонки);
	 Если СтрокаДерева = Неопределено Тогда	
		 ПолучитьСтрокуИзДерева(Дерево, ИскомоеЗначение, ИмяКолонки);	
	 Иначе 
		 НайденаСтрока = СтрокаДерева;
		 Уровень = СтрокаДерева.Уровень(); 
		 Родитель = ?(ЗначениеЗаполнено(СтрокаДерева.Родитель), СтрокаДерева.Родитель, Неопределено );
	 КонецЕсли;  
	 
 КонецПроцедуры
 
 // Получает Индекс значения в дереве
 // 
 // Параметры:
 //  Дерево - дерево значений, содержащее данные объекта
 //  ИскомаяСтрока - имя Строки,
 //  Индекс
 //  
 //
 Процедура  ПолучитьИндексЗначенияДерева(Дерево, ИскомаяСтрока, Строки = Неопределено ,  Индекс = Неопределено, Родитель = Неопределено ) Экспорт
	 
	 СтрокаДерева = Дерево.Строки;
	 Для каждого строка Из СтрокаДерева Цикл
		 Если строка = ИскомаяСтрока Тогда	
			 Строки = СтрокаДерева;
			 Родитель =  ?(ЗначениеЗаполнено(строка.Родитель), строка.Родитель , Неопределено );
			 Индекс = СтрокаДерева.Индекс(ИскомаяСтрока); 
			 Возврат;
		 КонецЕсли; 
	 КонецЦикла;  
	 ПолучитьИндексЗначенияДерева(СтрокаДерева, ИскомаяСтрока);
	 
 КонецПроцедуры
 
 Процедура УстановитьРодителейДляВерхнихСтрок(Дерево, ТекущийРодитель, НовыйВладелец = Неопределено) Экспорт 
	 
	 Если  ТекущийРодитель.Строки.Количество() > 0 Тогда 
		 
		 Если ТекущийРодитель.родитель <> Неопределено Тогда
			 НовыйВладелец = ТекущийРодитель.родитель;
		 КонецЕсли;
		 
		 Для Каждого СтрокаДерева из ТекущийРодитель.Строки Цикл
			 
			 СтрокаGUID = "00000000-0000-0000-0000-000000000000"; 
			 ПустойУИдентификатор = Новый УникальныйИдентификатор(СтрокаGUID); 
			 
			 Если СтрокаДерева.Владелец <> ПустойУИдентификатор тогда	
				 СтрокаДерева.Владелец  =  ТекущийРодитель.Идентификатор;
				 СтрокаДерева.Идентификатор  = Новый УникальныйИдентификатор;
				 СтрокаДерева.НомерСтроки = Неопределено;
				 СтрокаДерева.ДатаНачалаПериода = Неопределено;
				 СтрокаДерева.ДатаОкончанияПериода =Неопределено;
				 СтрокаДерева.Количество= ТекущийРодитель.Количество;
				 
				 КолонкаРаспечатан = Дерево.Колонки.Найти("Распечатан");
				 Если КолонкаРаспечатан <> Неопределено  тогда
					 СтрокаДерева.Распечатан = Неопределено;
				 КонецЕсли;
				 
				 КолонкаОригиналРаспечатан = Дерево.Колонки.Найти("ОригиналРаспечатан");
				 Если КолонкаОригиналРаспечатан <> Неопределено  тогда
					 СтрокаДерева.ОригиналРаспечатан = Неопределено;
				 КонецЕсли;
				 
				 КолонкаВыполненн= Дерево.Колонки.Найти("Выполненн");
				 Если КолонкаВыполненн <> Неопределено  тогда
					 СтрокаДерева.Выполненн = Неопределено;
				 КонецЕсли;
				 
				 КолонкаОригиналВыполненн = Дерево.Колонки.Найти("ОригиналВыполненн");
				 Если КолонкаОригиналВыполненн <> Неопределено  тогда
					 СтрокаДерева.ОригиналВыполненн = Неопределено;
				 КонецЕсли;
				 
			 КонецЕсли;
			 
			 Если  СтрокаДерева.Строки.Количество() > 0 Тогда 
				 УстановитьРодителейДляВерхнихСтрок(Дерево, СтрокаДерева, НовыйВладелец);                       
			 КонецЕсли;
			 
		 КонецЦикла;    	
	 КонецЕсли;
	 
 КонецПроцедуры
 
 //Дерево на форме
 Процедура ВклВыклВсе(Дерево, КолонкаФлажка= "Флаг", Состояние ) Экспорт
	Для каждого СтрокаДерева Из Дерево.Строки Цикл
		СтрокаДерева[КолонкаФлажка]= Состояние;
		ОтметитьДетей(СтрокаДерева, КолонкаФлажка);
	КонецЦикла;
КонецПроцедуры

Процедура ОтметитьДетей(ТекущаяСтрокаДерева, Колонка = "Флаг") Экспорт
	Для каждого СтрокаДерева из ТекущаяСтрокаДерева.Строки Цикл
		СтрокаДерева[Колонка]=ТекущаяСтрокаДерева[Колонка];
		ОтметитьДетей(СтрокаДерева , Колонка);
	КонецЦикла;
КонецПроцедуры

Процедура ОтметитьРодителей(ТекущаяСтрокаДерева, Колонка= "Флаг") Экспорт
	ТекущийРодитель=ТекущаяСтрокаДерева.Родитель;
	Если ТекущийРодитель=Неопределено Тогда
		Возврат 
	КонецЕсли;
	
	Соотв=Новый Соответствие; 	
	Для Каждого СтрокаДерева из ТекущийРодитель.Строки Цикл
		Соотв.Вставить(Строка(СтрокаДерева[Колонка]),Истина); 
		Если Соотв.Количество()>1 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ТекущийРодитель[Колонка]=?(Соотв.Количество()>1,2,СтрокаДерева[Колонка]);
	ОтметитьРодителей(ТекущийРодитель, Колонка);
КонецПроцедуры

Процедура ДеревоВСписок(Список, ТекущаяСтрокаДерева, КолонкаПредставления, КолонкаФлажка= "Флаг", Уровень=0) Экспорт
	Для Каждого СтрокаДерева из ТекущаяСтрокаДерева.Строки Цикл 
		стр="";
		Для й=1 по Уровень Цикл 
			стр=стр+"	" 
		КонецЦикла;
		Если СтрокаДерева.Строки.Количество()>0 Тогда 
			ПредставлениеСтрокиДерева=СокрЛП(СтрокаДерева[КолонкаПредставления]);
			ПредставлениеСтрокиДерева=?(ПустаяСтрока(ПредставлениеСтрокиДерева),"< пусто >",ПредставлениеСтрокиДерева);
			Список.Добавить(СтрокаДерева, стр + ПредставлениеСтрокиДерева,СтрокаДерева[КолонкаФлажка]<>0); 
		КонецЕсли;
		ДеревоВСписок(Список, СтрокаДерева, КолонкаПредставления, КолонкаФлажка, Уровень+1);
	КонецЦикла;
КонецПроцедуры

Процедура УдалитьНеотмеченные(ТекущаяСтрокаДерева ,Колонка )Экспорт
	ЛишниеСтроки=ТекущаяСтрокаДерева.Строки.НайтиСтроки(Новый Структура(Колонка,0),Ложь);
	Для Каждого СтрокаДерева из ЛишниеСтроки Цикл
		ТекущаяСтрокаДерева.Строки.Удалить(СтрокаДерева);
	КонецЦикла;
	Для Каждого СтрокаДерева Из ТекущаяСтрокаДерева.Строки Цикл
		СтрокаДерева[Колонка]=1;
		УдалитьНеотмеченные(СтрокаДерева, Колонка);
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет дерево значений по таблице значений, достраивая иерархию по одной из колонок тз
//
//  Параметры:
//   1.Дерево - ТабличноеПоле - должен быть установен тип значения "ДеревоЗначений"
//   2.Таблица - ТабличноеПоле - должен быть установен тип значения "ТаблицаЗначений"
//   3.ИмяКолонки - Строка - имя колонки по которой должна быть достроена несуществующая иерархия
//   4.СтруктураКолонокПересчета - Структура - Структура с именами колонок требующих пересчета и функциями пересчета
//
Процедура ЗаполнитьДеревоПоТаблице(Дерево,Таблица,ИмяКолонки,СтруктураКолонокПересчета) Экспорт
	
	// для последующего изменения ТЗ по ДЗ
	СоответствиеСтрок = Новый Соответствие;
	
	Запрос = Новый Запрос;
	МВТ = Новый МенеджерВременныхТаблиц;
	Запрос.МенеджерВременныхТаблиц = МВТ;
	Запрос.Текст = "ВЫБРАТЬ ";
	СЧ = 0;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СЧ = СЧ + 1;
		Запрос.Текст = Запрос.Текст + Символы.ПС + "ТЗСостав."+ Колонка.Имя + " КАК "+ Колонка.Имя + ?(СЧ = Таблица.Колонки.Количество(),"",",");
	КонецЦикла;
	Запрос.Текст = Запрос.Текст + Символы.ПС + "ПОМЕСТИТЬ ТЗВременная
	|ИЗ
	|	&ТЗСостав КАК ТЗСостав";
	
	Запрос.УстановитьПараметр("ТЗСостав",Таблица.Значение);
	Запрос.Выполнить();
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МВТ;
	Запрос.Текст = "ВЫБРАТЬ ";
	СЧ = 0;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СЧ = СЧ + 1;
		Запрос.Текст = Запрос.Текст + Символы.ПС + "ТЗСостав."+ Колонка.Имя + " КАК "+ Колонка.Имя + ?(СЧ = Таблица.Колонки.Количество(),"",",");
	КонецЦикла;
	Запрос.Текст = Запрос.Текст + Символы.ПС + " ИЗ
	|	ТЗВременная КАК ТЗСостав
	|СГРУППИРОВАТЬ ПО ";
	СЧ = 0;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СЧ = СЧ + 1;
		Запрос.Текст = Запрос.Текст + Символы.ПС + "ТЗСостав."+ Колонка.Имя + ?(СЧ = Таблица.Колонки.Количество(),"",",");
	КонецЦикла;
    Запрос.Текст = Запрос.Текст + Символы.ПС + "
	|ИТОГИ";
	СЧ = 0;
	Для Каждого КолонкаПересчета Из СтруктураКолонокПересчета Цикл
		СЧ = СЧ + 1;
		Запрос.Текст = Запрос.Текст + Символы.ПС + КолонкаПересчета.Значение + " ("+ КолонкаПересчета.Ключ + ")" + ?(СЧ = СтруктураКолонокПересчета.Количество(),"",",");	
	КонецЦикла;
	Запрос.Текст = Запрос.Текст + Символы.ПС + "ПО
	|	" + ИмяКолонки + " ТОЛЬКО ИЕРАРХИЯ";
	Дерево.Значение = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	Дерево.СоздатьКолонки();
	
	// оформление колонок
	Для Каждого Колонка Из Таблица.Колонки Цикл
		КолонкаДерева = Дерево.Колонки[Колонка.Имя];
		ЗаполнитьЗначенияСвойств(КолонкаДерева,Колонка);
	КонецЦикла;
	Дерево.Колонки[ИмяКолонки].ОтображатьИерархию = Истина;
КонецПроцедуры //ЗаполнитьДеревоПоТаблице()

////////////////////////////////////////////////////////////////

//ОбщегоНазначенияСервер.ПолучитьСписокИерархииССылки
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
 Функция ПолучитьСписокИерархииССылки(ССылка, справочник="Номенклатура") Экспорт 
	 //Запрос = Новый Запрос;
	 //Запрос.УстановитьПараметр("СсылкаНаЭлемент", ССылка );
	 //Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ различные
	 //|	ТНоменклатура.Ссылка КАК Ссылка
	 //|ИЗ
	 //|	Справочник."+ справочник +" КАК ТНоменклатура
	 //|ГДЕ
	 //|	ТНоменклатура.Ссылка В ИЕРАРХИИ(&СсылкаНаЭлемент)
	 //|  
	 //|УПОРЯДОЧИТЬ ПО
	 //|	Ссылка
	 //|ИТОГИ ПО
	 //|	Ссылка ТОЛЬКО ИЕРАРХИЯ
	 //|АВТОУПОРЯДОЧИВАНИЕ";
	 
	 //Костенюк Александр-Старт 27.11.2012
	 Запрос = Новый Запрос;
	 Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	                |	ТНоменклатура.Ссылка КАК Ссылка
	                |ИЗ
	                |	Справочник.Номенклатура КАК ТНоменклатура
	                |ГДЕ
	                |	ТНоменклатура.Ссылка В ИЕРАРХИИ(&СсылкаНаЭлемент)
	                |
	                |УПОРЯДОЧИТЬ ПО
	                |	Ссылка
	                |ИТОГИ ПО
	                |	Ссылка ТОЛЬКО ИЕРАРХИЯ
	                |АВТОУПОРЯДОЧИВАНИЕ";
	 Запрос.УстановитьПараметр("СсылкаНаЭлемент", Ссылка);
	 Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.Номенклатура КАК ТНоменклатура", "Справочник." + Справочник + " КАК ТНоменклатура");
	 //Костенюк Александр-Финиш 27.11.2012
	 
	 СписокЗапроса = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	 
	 Возврат СписокЗапроса;
	 
 КонецФункции
 
 Функция ПолучитьВерхнийУровеньВСправочнике(справочник="Номенклатура") Экспорт 	
	 
	 Запрос = Новый Запрос;
	 Запрос.Текст = "ВЫБРАТЬ
	 |	Спр.Ссылка
	 |ИЗ
	 |	Справочник."+справочник+" КАК Спр
	 |ГДЕ
	 |	Спр.Родитель.Ссылка ЕСТЬ NULL ";
	 
	 СписокЗапроса = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");	
	 Возврат СписокЗапроса;
	 
 КонецФункции
 
 Функция СозданиеИИзменениеМодификаторов(Ссылка, знач ОбъектМетаданных ="МодификаторыНоменклатуры" ) Экспорт 
	 
	 
	 СсылкаМодификатор=Справочники[ОбъектМетаданных].НайтиПоРеквизиту("Номенклатура", Ссылка ).ПолучитьОбъект();
	 
	 Если  СсылкаМодификатор<>Неопределено   Тогда
		 Если не СсылкаМодификатор.ПометкаУдаления Тогда
			 
			 Если  не СсылкаМодификатор.Родитель.Пустая() тогда 
				 Если СсылкаМодификатор.Наименование = "" Тогда
					 СсылкаМодификатор.Наименование = Ссылка.Наименование;
					 СсылкаМодификатор.Записать();
					 Возврат СсылкаМодификатор;
				 Иначе 
					 Возврат СсылкаМодификатор;
				 КонецЕсли;
				 
			 Иначе 
				 //Если Ссылка.Родитель.Пустая() Тогда
				 
				 Если СсылкаМодификатор.Наименование = "" Тогда
					 СсылкаМодификатор.Наименование = Ссылка.Наименование;
					 СсылкаМодификатор.Записать();
					 Возврат СсылкаМодификатор;
				 Иначе 
					 Возврат СсылкаМодификатор;
				 КонецЕсли;
				 
				 //Иначе 
				 НовыйРодитель = Справочники[ОбъектМетаданных].СоздатьГруппу();
				 НовыйРодитель.Наименование = Ссылка.Родитель.Наименование;
				 НовыйРодитель.Записать();
				 СсылкаМодификатор.Родитель = НовыйРодитель;
				 СсылкаМодификатор.записать();
				 Если СсылкаМодификатор.Наименование = "" Тогда
					 СсылкаМодификатор.Наименование = Ссылка.Наименование;
					 СсылкаМодификатор.Записать();
					 Возврат СсылкаМодификатор;
				 Иначе 
					 Возврат СсылкаМодификатор;
				 КонецЕсли;
				 
				 //					 Возврат СсылкаМодификатор;
				 
				 //КонецЕсли; 
				 
			 КонецЕсли; 
		 КонецЕсли; 		 
		 
		 
	 Иначе 
		 Если Ссылка.Родитель.Пустая() и Ссылка.ЭтоГруппа Тогда
			 НовыйСправочник= Справочники[ОбъектМетаданных].СоздатьГруппу();
			 НовыйСправочник.Родитель =Справочники[ОбъектМетаданных].ПустаяСсылка(); 
			 НовыйСправочник.Наименование = Ссылка.Наименование;
			 НовыйСправочник.Номенклатура = Ссылка;
			 НовыйСправочник.Актуальность = Истина; 
			 НовыйСправочник.Записать();
			 
		 ИначеЕсли не Ссылка.Родитель.Пустая() и Ссылка.ЭтоГруппа Тогда 
			 
			 НовыйСправочник= Справочники[ОбъектМетаданных].СоздатьГруппу();
			 ЭтоРодитель = Справочники[ОбъектМетаданных].НайтиПоРеквизиту("Номенклатура", Ссылка );
			 Если ЗначениеЗаполнено(ЭтоРодитель) Тогда
				 НовыйСправочник.Родитель = ЭтоРодитель;
			 Иначе 
				 НовыйРодитель = Справочники[ОбъектМетаданных].СоздатьГруппу();
				 НовыйРодитель.Наименование = Ссылка.Родитель.Наименование;
				 НовыйРодитель.Записать();
				 НовыйСправочник.Родитель = НовыйРодитель;
			 КонецЕсли; 
			 
			 НовыйСправочник.Наименование = Ссылка.Наименование;
			 НовыйСправочник.Номенклатура = Ссылка;
			 НовыйСправочник.Актуальность = Истина;
			 НовыйСправочник.Записать();
			 
			 
		 ИначеЕсли не Ссылка.ЭтоГруппа тогда
			 Если Ссылка.Родитель.Пустая()  Тогда
				 НовыйСправочник= Справочники[ОбъектМетаданных].СоздатьЭлемент();
				 НовыйСправочник.Родитель = Справочники[ОбъектМетаданных].ПустаяСсылка() ;
				 НовыйСправочник.Наименование = Ссылка.Наименование;
				 НовыйСправочник.Номенклатура = Ссылка;
				 НовыйСправочник.Актуальность = Истина; 
				 НовыйСправочник.Записать(); 
			 Иначе 
				 
				 НовыйСправочник= Справочники[ОбъектМетаданных].СоздатьЭлемент();
				 ЭтоРодитель = Справочники[ОбъектМетаданных].НайтиПоРеквизиту("Номенклатура", Ссылка).Родитель;
				 Если ЗначениеЗаполнено(ЭтоРодитель) Тогда
					 НовыйСправочник.Родитель = ЭтоРодитель;
				 Иначе 
					 НовыйРодитель = Справочники[ОбъектМетаданных].СоздатьГруппу();
					 НовыйРодитель.Наименование = Ссылка.Родитель.Наименование;
					 НовыйРодитель.Записать();
					 НовыйСправочник.Родитель = НовыйРодитель;
				 КонецЕсли; 
				 НовыйСправочник.Номенклатура = Ссылка;
				 НовыйСправочник.Наименование = Ссылка.Наименование;
				 НовыйСправочник.Актуальность = Истина; 
				 НовыйСправочник.Записать();
				 
			 КонецЕсли; 
		 КонецЕсли;
		 Возврат НовыйСправочник.Ссылка;
		 
	 КонецЕсли; 
 КонецФункции
 
 // Создаёт по иерархии Номенклатуры группы ОбъектМетаданных
 //  ССылка =ссылка на номенклатуру по которой будет созданы группы
 // ОбъектМетаданных 
 Функция  СозданиеРекурсиейГрупп(ССылка, ОбъектМетаданных = Неопределено) Экспорт 
	 Перем группа;	
	 Если ОбъектМетаданных = Неопределено Тогда
		 //Сообщить("Не задан объект метаданных!!!");
		 Возврат Неопределено;
	 КонецЕсли; 
	 
	 Запрос = Новый Запрос;
	 Запрос.УстановитьПараметр("СсылкаНаЭлемент",ССылка );
	 Запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
	 |	ТНоменклатура.Ссылка.Родитель КАК Ссылка
	 |ИЗ
	 |	Справочник.Номенклатура КАК ТНоменклатура
	 |ГДЕ
	 |	ТНоменклатура.Ссылка В ИЕРАРХИИ(&СсылкаНаЭлемент)
	 |
	 |УПОРЯДОЧИТЬ ПО
	 |	Ссылка
	 |ИТОГИ ПО
	 |	Ссылка ТОЛЬКО ИЕРАРХИЯ
	 |АВТОУПОРЯДОЧИВАНИЕ";
	 
	 СписокЗапроса = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	 
	 Для Инд = 0 по  СписокЗапроса.Количество()- 1 Цикл
		 РодительГрупп =Справочники[ОбъектМетаданных].НайтиПоРеквизиту("Номенклатура",СписокЗапроса[Инд]);
		 Если  РодительГрупп.Пустая() Тогда
			 НоваяГруппа = Справочники[ОбъектМетаданных].СоздатьГруппу();
			 НоваяГруппа.Наименование =  СписокЗапроса[Инд].Наименование;
			 НоваяГруппа.Номенклатура = СписокЗапроса[Инд].Ссылка; 
			 НоваяГруппа.Актуальность = Истина;
			 Если  Инд <> 0 Тогда
				 НоваяГруппа.Родитель = группа; 	
			 КонецЕсли; 
			 Попытка
				 НоваяГруппа.Записать();
			 Исключение
				 Сообщить(НСтр("ru ='"+"Не удалось записать " + ССылка.Наименование +" "+ОписаниеОшибки()+"'"), СтатусСообщения.Внимание);
			 КонецПопытки;
			 
			 группа = НоваяГруппа.Ссылка;
			 
		 Иначе 
			 
			 группа = РодительГрупп;
		 КонецЕсли; 
		 
	 КонецЦикла; 
	 
	 Возврат группа;
	 
 КонецФункции
 
 // Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
 //
 // Параметры:
 //  ИмяТЧ - Строка. Имя табличной части.
 //  НомерСтроки - Число. Номер строки табличной части.
 //  ИмяРеквизита - Строка. Имя реквизита.
 //
 // Возвращаемое значение:
 //  Строка.
 //
 Функция ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(ИмяТЧ, НомерСтроки, ИмяРеквизита) Экспорт
	 
	 Возврат ИмяТЧ + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;
	 
 КонецФункции // ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()
 
 // Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
 // 
 // Параметры:
 //  Разрядность 			- число, разряд числа.
 //  РазрядностьДробнойЧасти - число, разряд дробной части.
 //
 // Возвращаемое значение:
 //  Объект "ОписаниеТипов" для числа указанной разрядности.
 //
 Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти) Экспорт
	 
	 Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти));
	 
 КонецФункции // ПолучитьОписаниеТиповЧисла()
 
 // Служебная функция, предназначенная для получения описания типов даты
 // 
 // Параметры:
 //  ЧастиДаты - системное перечисление ЧастиДаты.
 // 
 Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	 
	 Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));
	 
 КонецФункции // ПолучитьОписаниеТиповДаты()
 
 Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник) Экспорт
	 
	 Для каждого СтрокаИсточника Из Источник Цикл
		 ЗаполнитьЗначенияСвойств(Приемник.Добавить(), СтрокаИсточника);
	 КонецЦикла;
	 
 КонецПроцедуры
 
 Процедура ПронумероватьТаблицуЗначений(ТЗ, ИмяКолонкиНомераСтроки) Экспорт
	 
	 ТЗ.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	 
	 КоличествоСтрок = ТЗ.Количество() - 1;
	 Для НомерСтроки = 0 По КоличествоСтрок Цикл
		 ТЗ[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	 КонецЦикла;
	 
 КонецПроцедуры
 
 Процедура УстановитьНовоеЗначениеРеквизита(Знач Объект, НовоеЗначение, ИмяРеквизита) Экспорт
	 
	 Если Объект[ИмяРеквизита] <> НовоеЗначение Тогда
		 
		 Объект[ИмяРеквизита] = НовоеЗначение;
		 
	 КонецЕсли;
	 
 КонецПроцедуры
 
 Функция ПолучитьМассивПустыхТипов(Реквизит) Экспорт
	 
	 МассивПустыхТипов = Новый Массив;
	 Для Каждого ТипЗначения Из Реквизит.Тип.Типы() Цикл
		 
		 МассивПустыхТипов.Добавить(Новый (ТипЗначения));
		 
	 КонецЦикла;
	 
	 Возврат МассивПустыхТипов;
	 
 КонецФункции
 
 Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	 
	 Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		 Возврат Неопределено;
	 КонецЕсли;
	 
	 ИндексМакс = 0;
	 МаксЗнач   = 0;
	 РаспрСумма = 0;
	 СуммаКоэф  = 0;
	 
	 Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		 
		 МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		 
		 Если МаксЗнач < МодульЧисла Тогда
			 МаксЗнач = МодульЧисла;
			 ИндексМакс = К;
		 КонецЕсли;
		 
		 СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		 
	 КонецЦикла;
	 
	 Если СуммаКоэф = 0 Тогда
		 Возврат Неопределено;
	 КонецЕсли;
	 
	 МассивСумм = Новый Массив(МассивКоэф.Количество());
	 
	 Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		 МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		 РаспрСумма = РаспрСумма + МассивСумм[К];
	 КонецЦикла;
	 
	 // Погрешности округления отнесем на коэффицент с максимальным весом
	 Если Не РаспрСумма = ИсхСумма Тогда
		 МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	 КонецЕсли;
	 
	 Возврат МассивСумм;
	 
 КонецФункции
 
 Функция ПолучитьПредставлениеНоменклатуры(НоменклатураПредставление, ХарактеристикаПредставление) Экспорт
	 
	 СтрПредставление = СокрЛП(НоменклатураПредставление);
	 
	 Если ЗначениеЗаполнено(ХарактеристикаПредставление)Тогда
		 СтрПредставление = СтрПредставление + " / " + СокрЛП(ХарактеристикаПредставление);
	 КонецЕсли;
	 
	 Возврат СтрПредставление;
	 
 КонецФункции
 
 Процедура СообщитьОбОшибкеВыполненияОперации(Объект, УдалениеПроведения) Экспорт
	 
	 ТекстСообщения = ?(УдалениеПроведения, НСтр("ru = 'Отмена проведения не выполнена!'"), НСтр("ru = 'Проведение не выполнено!'"));
	 ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, Объект);
	 
 КонецПроцедуры
 
 Функция ПолучитьЗначенияРеквизитовОбъекта(Ссылка, СтруктураПолей) Экспорт
	 
	 Результат = Новый Структура;
	 Для Каждого КлючИЗначение ИЗ СтруктураПолей Цикл
		 Результат.Вставить(КлючИЗначение.Ключ);
	 КонецЦикла;
	 
	 ТекстЗапроса = "";
	 
	 ОбъектМетаданных = Ссылка.Метаданные();
	 
	 Для Каждого Элемент Из СтруктураПолей Цикл
		 
		 ИмяПоля = Элемент.Значение;
		 
		 Если НЕ ЗначениеЗаполнено(ИмяПоля) Тогда
			 ИмяПоля = СокрЛП(Элемент.Ключ);
		 КонецЕсли;
		 
		 ТекстЗапроса  = ТекстЗапроса + ?(ПустаяСтрока(ТекстЗапроса), "", ",") + "
		 |	" + ИмяПоля + " КАК " + СокрЛП(Элемент.Ключ);
	 КонецЦикла;
	 
	 Запрос = Новый Запрос();
	 
	 Запрос.Текст =
	 "ВЫБРАТЬ РАЗРЕШЕННЫЕ" + ТекстЗапроса + "
	 |ИЗ
	 |	" + ОбъектМетаданных.ПолноеИмя() + " КАК ТаблицаОбъекта
	 |ГДЕ
	 |	Ссылка = &Ссылка";
	 
	 Запрос.УстановитьПараметр("Ссылка" , Ссылка);
	 
	 Выборка = Запрос.Выполнить().Выбрать();
	 
	 Если Выборка.Следующий() Тогда
		 Для Каждого КлючИЗначение ИЗ СтруктураПолей Цикл
			 Результат[КлючИЗначение.Ключ] = Выборка[КлючИЗначение.Ключ];
		 КонецЦикла;
	 КонецЕсли;
	 
	 Возврат Результат;
	 
 КонецФункции
 
 // Получает и возвращает запрос из переданного макета компоновки данных
 //
 // Параметры:
 //  Макет - макет компоновки данных, из которого требуется получить запрос.
 //  ИмяНабораДанных - имя набора данных из макета, для которого получается запрос.
 //
 // Возвращаемое значение:
 //  Запрос, сформированный на основании макета компоновки
 //
 Функция ПолучитьЗапросИзМакетаКомпоновки(Макет, ИмяНабораДанных) Экспорт
	 
	 Запрос = Новый Запрос(Макет.НаборыДанных[ИмяНабораДанных].Запрос);
	 
	 Для Каждого Параметр Из Макет.ЗначенияПараметров Цикл
		 Запрос.УстановитьПараметр(Параметр.Имя, Параметр.Значение);
	 КонецЦикла;
	 
	 Возврат Запрос;
	 
 КонецФункции
 
 // Получает и возвращает макет компоновки данных для схемы компоновки
 //
 // Параметры:
 //  СхемаКомпоновки - схема компоновки данных, для которой получается макет компоновки
 //  Настройки - настройки компоновки, применяемые к схеме
 //
 // Возвращаемое значение:
 //  Макет компоновки данных
 //
 Функция ПолучитьМакетКомпоновки(СхемаКомпоновки, Настройки) Экспорт
	 
	 КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	 
	 Возврат КомпоновщикМакета.Выполнить(СхемаКомпоновки, Настройки, , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	 
 КонецФункции
 
 ////////////////////////////////////////////////////////////////////////////////
 // ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ПРЕДСТАВЛЕНИЯ ДАННЫХ
 //
 
 Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	 
	 Возврат Ссылка.Метаданные().Синоним + " " + Номер + " от " + Формат(Дата,"ДЛФ=D");
	 
 КонецФункции // ПолучитьПредставлениеДокумента()
 
 Функция ПолучитьПредставлениеПериода(ДатаНачалаПериода, ДатаОкончанияПериода) Экспорт
	 
	 Возврат ПредставлениеПериода(ДатаНачалаПериода, ДатаОкончанияПериода);
	 
 КонецФункции // ПолучитьПредставлениеПериода()
 
 // Возвращает сокращенное строковое представление коллекции значений
 // 
 // Параметры:
 //  Коллекция 						- массив или список значений.
 //  МаксимальноеКоличествоЭлементов - число, максимальное количество элементов включаемое в представление.
 //
 // Возвращаемое значение:
 //  Строка.
 //
 Функция ПолучитьСокращенноеПредставлениеКоллекцииЗначений(Коллекция, МаксимальноеКоличествоЭлементов = 2) Экспорт
	 
	 СтрокаПредставления = "";
	 
	 КоличествоЗначений			 = Коллекция.Количество();
	 КоличествоВыводимыхЭлементов = Мин(КоличествоЗначений, МаксимальноеКоличествоЭлементов);
	 
	 Если КоличествоВыводимыхЭлементов = 0 Тогда
		 
		 Возврат "";
		 
	 Иначе
		 
		 Для НомерЗначения = 1 По КоличествоВыводимыхЭлементов Цикл
			 
			 СтрокаПредставления = СтрокаПредставления + Коллекция.Получить(НомерЗначения - 1) + ", ";	
			 
		 КонецЦикла;
		 
		 СтрокаПредставления = Лев(СтрокаПредставления, СтрДлина(СтрокаПредставления) - 2);
		 Если КоличествоЗначений > КоличествоВыводимыхЭлементов Тогда
			 СтрокаПредставления = СтрокаПредставления + ", ... ";
		 КонецЕсли;
		 
	 КонецЕсли;
	 
	 Возврат СтрокаПредставления;
	 
 КонецФункции
 
 
 //БИБЛИОТЕКА: ПРЕДСТАВЛЕНИЕ КОЛЛЕКЦИЙ
 
 Функция МассивВСтроку(С,Разделитель=",") Экспорт
	 //Назначение: Преобразует массив в строку с заданным разделителем
	 //ДатаСоздания: 20070619
	 //Автор: Fixin
	 //Тестирована: Да
	 Перем Р;
	 Р="";
	 Для Каждого Эл ИЗ С Цикл
		 Р=Р+?(Р="","",Разделитель)+Строка(Эл);
	 КонецЦикла;
	 Возврат Р;
 КонецФункции
 
 Функция СписокВСтроку(С,Разделитель=",", Реквизит = "Значение") Экспорт
	 //ДатаСоздания: 20061001
	 //Тестирована: Нет
	 //Автор: Fixin
	 //Назначение: Выводит список по значению элементов в строку, можно использовать значение или представление
	 Перем Р;
	 Р="";
	 Для Каждого Эл ИЗ С Цикл
		 Р=Р+?(Р="","",Разделитель)+Строка(Эл[Реквизит]);
	 КонецЦикла;
	 Возврат Р;
 КонецФункции
 
 Функция СтруктураВСтроку(С, Разделитель=", ") Экспорт
	 //Назначение: Преобразует структуру в строку
	 //ДатаСоздания: 20070619
	 //Автор: Fixin
	 //Тестирована: Да
	 Перем Р;
	 Р="";
	 Для Каждого Эл ИЗ С Цикл
		 Р=Р+?(Р="","",Разделитель)+Строка(Эл.Ключ)+"="+Строка(Эл.Значение);
	 КонецЦикла;
	 Возврат Р;
 КонецФункции
 
 Функция КоллекцияВСтроку(Коллекция, П = Неопределено) Экспорт
	 //Назначение: Строковое представление коллекции
	 //ДатаСоздания: 20070510
	 //Автор: Fixin
	 //Тестирована: Нет
	 //$Коллекция: Коллекция
	 //$П: Параметры
	 //$П.Разделитель: Разделитель между элементами коллекции
	 Перем ТекРазделитель;
	 Если П.Свойство("Разделитель") Тогда
		 ТекРазделитель = П.Разделитель;
	 Иначе
		 ТекРазделитель = ",";
	 КонецЕсли;
	 
	 Р="";
	 Для Каждого Эл Из Коллекция Цикл
		 Если ТипЗнч(Эл)=Тип("КлючИЗначение") Тогда
			 ТекПредставление=Строка(Эл.Ключ)+"="+Строка(Эл.Значение);
		 Иначе
			 ТекПредставление=Строка(Эл);
		 КонецЕсли;
		 Р=Р+?(Р="","",ТекРазделитель)+ТекПредставление;
	 КонецЦикла;
	 Возврат Р;
 КонецФункции
 
 //БИБЛИОТЕКА: СПИСКИ ЗНАЧЕНИЙ
 
 Функция УстановитьВсеПометкиСписка(Список, Зн) Экспорт
	 //Назначение: Функция для установки/сброса/инверсии всех пометок списка
	 //$Список: СписокЗначений
	 //$Зн: Истина - установить пометки, Ложь - сбросить, иначе - инвертировать
	 //ДатаСоздания: 20060922
	 //Автор: Fixin
	 //Тестирована: Да
	 Для Каждого Поз Из Список Цикл
		 Если Зн=истина Тогда
			 Поз.Пометка=Истина;
		 ИначеЕсли Зн=ложь Тогда
			 Поз.Пометка=ложь;
		 Иначе //инверсия
			 Поз.Пометка=Не Поз.Пометка;
		 КонецЕсли;
	 КонецЦикла;	
 КонецФункции
 
 Функция УстановитьПометкиСпискаСогласноДругогоСписка(Получатель, Источник) Экспорт
	 //Функция для установки пометок списка-получателя согласно пометок списка-источника
	 //$Источник: СписокЗначений - источник пометок
	 //$Получатель: СписокЗначений - получатель пометок
	 //$Возврат: Получатель
	 //ДатаСоздания: 20060925
	 //Тестирована: Да
	 //Автор: Fixin
	 //СтароеИмя: УстановитьПометкуСпискаСогласноДругогоСписка
	 Для Каждого Эл из Источник Цикл
		 Зн=Получатель.НайтиПоЗначению(Эл.Значение);
		 Если Зн<>Неопределено Тогда
			 Зн.Пометка=Эл.Пометка;
		 КонецЕсли;
	 КонецЦикла;
	 Возврат Получатель;
 КонецФункции
 
 Функция ОбъединитьСписки(К1, К2, Уникальность=истина, флНовый=истина) Экспорт
	 //ДатаСоздания: 20061001
	 //Тестирована: Да
	 //Автор: Fixin
	 //Назначение: Объединить два списка, элементы добавляются в конец первого списка
	 //$флНовый - если истина, то создается новый список, иначе добавляется в К1
	 //$Уникальность - если истина, то добавляются только уникальные элементы
	 Если флНовый Тогда
		 Получатель=К1.Скопировать();
	 Иначе
		 Получатель=К1;
	 КонецЕсли;
	 
	 Для Каждого Эл ИЗ К2 Цикл
		 Если Уникальность И Получатель.НайтиПоЗначению(Эл.Значение)<>Неопределено Тогда //20071126 поправлено by fixin
			 Продолжить;
		 КонецЕсли;
		 Получатель.Добавить(Эл.Значение, Эл.Представление); //20071129 поправлено by fixin, было просто Эл
	 КонецЦикла;
	 
	 Возврат Получатель;
 КонецФункции
 
 Функция ПересечьСписки(К1, К2, флНовый=истина) Экспорт
	 //ДатаСоздания: 20061001
	 //Тестирована: Да
	 //Автор: Fixin
	 //Назначение: Список, состоящий из элементов, которые есть в обоих списков
	 //$флНовый - если истина, то создается новый список, иначе добавляется в К1
	 //$Уникальность - если истина, то добавляются только уникальные элементы
	 Получатель=Новый СписокЗначений();
	 Для Каждого Эл ИЗ К2 Цикл
		 Если К1.НайтиПоЗначению(Эл.Значение)<>Неопределено Тогда //bug fix 20080226
			 Получатель.Добавить(Эл.Значение);
		 КонецЕсли;
	 КонецЦикла;
	 
	 Если НЕ флНовый Тогда
		 К1=Получатель;
	 КонецЕсли;
	 
	 Возврат Получатель;
 КонецФункции
 
 Функция ДобавитьВСписокУникально(Список, Значение, Представление="", Пометка=Ложь, _Картинка=Неопределено) Экспорт
	 //Назначение: Добавляет в список значение только если его нет в списке. 
	 //$Представление: Представление значения, если не задано, не указывается.
	 //$Возврат: Возвращает элемент списка существующего/найденного элемента
	 //Описание:
	 //	Проверить, что было добавление можно путем контроля размера списка до и после (если надо)
	 //Тест: 
	 //	//(выдает 1,2)
	 //	Список=Новый СписокЗначений();
	 //	ДобавитьВСписокУникально(Список, 1);
	 //	ДобавитьВСписокУникально(Список, 2, "Вася");
	 //	ДобавитьВСписокУникально(Список, 1);
	 //	Сообщить(бфКоллекции.СписокВСтроку(Список));
	 //ДатаСоздания: 20071204
	 //СтароеИмя: ДобавитьУникальноВСписокЗначений
	 //Тестирована: Да
	 //Автор: Fixin
	 //??? Как быть с картинкой в клиент-сервере
	 Эл=Список.НайтиПоЗначению(Значение);
	 Если Эл=Неопределено Тогда
		 Если _Картинка=Неопределено Тогда
			 #Если Клиент Тогда
				 Картинка=Новый Картинка();	
			 #Иначе
				 Картинка=_Картинка;	
			 #КонецЕсли
		 Иначе
			 Картинка=_Картинка;	
		 КонецЕсли;
		 Эл=Список.Добавить(Значение, Представление, Пометка, Картинка);
	 КонецЕсли;
	 Возврат Эл;
 КонецФункции
 
 Функция ИзвлечьПомеченныеЭлементыСписка(Зн, Пометка=истина)Экспорт
	 //ДатаСоздания: 20080215
	 //Тестирована: Да
	 //Автор: Fixin
	 //Назначение: Копирует список значений, в копии остаются только те элементы, которые были помечены в соответствии с Пометка
	 #Если Клиент Тогда
		 Перем Р;
		 Р=Новый СписокЗначений();
		 
		 Для Каждого Эл ИЗ Зн Цикл
			 Если Эл.Пометка=Пометка Тогда
				 Р.Добавить(Эл.Значение, Эл.Представление, Эл.Пометка, Эл.Картинка);
			 КонецЕсли;
		 КонецЦикла;
		 Возврат Р;
	 #КонецЕсли
 КонецФункции
 
 Функция СписокИзЗначения(Зн) Экспорт
	 //Назначение: Возвращает список значений из единственного значения
	 //ДатаСоздания: 20070816 
	 //Автор: Fixin
	 //Тестирована: Да
	 Перем С;
	 С=Новый СписокЗначений();
	 С.Добавить(Зн);
	 Возврат С;
 КонецФункции
 
 //БИБЛИОТЕКА: СТРУКТУРЫ
 
 Функция СвойствоСтруктуры(Структура, Свойство, ЗначениеПоУмолчанию=Неопределено) Экспорт
	 //Назначение: Возвращает свойство структуры, а если его нет, то переданный параметр по умолчанию
	 //ДатаСоздания: 20070531
	 //Автор: Fixin
	 //СтароеИмя: СтруктураСвойство
	 //Тестирована: Да
	 Перем Значение;
	 Если Структура=Неопределено Тогда
		 Возврат ЗначениеПоУмолчанию;
	 КонецЕсли;
	 Если Структура.Свойство(Свойство, Значение) Тогда
		 Возврат Значение;
	 КонецЕсли;
	 Возврат ЗначениеПоУмолчанию;
 КонецФункции
 
 Функция СкопироватьСтруктуру(С) Экспорт
	 //Назначение: Копирует структуру. Почему-то в 1С можно скопировать список, таблицу значений, дерево значений, но не структуру
	 //ДатаСоздания: 20070620
	 //Автор: Fixin
	 //Тестирована: Нет
	 Перем Р;
	 Р=Новый Структура();
	 Для Каждого Эл ИЗ С Цикл
		 Р.Вставить(Эл.Ключ, Эл.Значение);
	 КонецЦикла;
	 Возврат Р;
 КонецФункции
 
 Функция СортироватьТаблицуПоПолям(ТЗ, МассивПолей) Экспорт
	 //Назначение: 
	 //ДатаСоздания: 20080215
	 //Автор: Fixin
	 //СтароеИмя: СортироватьТЗПоМассивуПолей
	 //Тестирована: Да
	 //Описание:
	 //	Сортирует таблицу ТЗ по массиву полей, имена полей указаны в значениях списка
	 //	Сортирует безопасно, т.е. если какого-то поля нет, оно пропускается.
	 М=Новый Массив();
	 Для Каждого Эл ИЗ МассивПолей Цикл
		 Если ТЗ.Колонки.Найти(Эл)<>Неопределено Тогда
			 М.Добавить(Эл);
		 КонецЕсли;
	 КонецЦикла;
	 Если М.Количество()<>0 Тогда
		 ТЗ.Сортировать(МассивВСтроку(М, ","));
	 КонецЕсли;
 КонецФункции
 
 Функция ПоискВСтруктуре(СтруктураДанных, Ключ, Значение) Экспорт
	 
	 ЗначениеНайдено = Неопределено;
	 Если  не СтруктураДанных.Свойство(Ключ,  ЗначениеНайдено) или ЗначениеНайдено = Неопределено  Тогда
		 СтруктураДанных.Вставить(Ключ, Значение);	 
	 КонецЕсли;	
	 
	 Если ЗначениеНайдено <> Значение Тогда
		 СтруктураДанных.Удалить(Ключ);
	 	 СтруктураДанных.Вставить(Ключ, Значение);	
	 КонецЕсли;
	 
	 Возврат  СтруктураДанных;
 КонецФункции


 //БИБЛИОТЕКА: ТАБЛИЦАЗНАЧЕНИЙ
 
 Функция СкопироватьКолонкиТаблицы(ТЗ, Поля = Неопределено) Экспорт
	 //Описание: Создает новую пустую таблицу значений с такими же колонками, как в исходной таблице значений
	 //Поля: Список полей, может быть не задан
	 Если Поля = Неопределено Тогда
		 С = Неопределено;
	 Иначе
		 С = Новый СписокЗначений();
		 С.ЗагрузитьЗначения(Поля);
	 КонецЕсли;
	 
	 Копия = Новый ТаблицаЗначений;
	 Для Каждого Колонка Из ТЗ.Колонки Цикл
		 Если С = Неопределено ИЛИ С.НайтиПоЗначению(Колонка.Имя) <> Неопределено Тогда
			 Копия.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
		 КонецЕсли;
	 КонецЦикла;
	 Возврат Копия;
 КонецФункции
 
 //Назначение: Удаляет строки таблицы значений по условию
 //ТЗ: Таблица значений
 //Код: Код проверки условия
 //Пример:
 //	УдалитьСтрокиТЗПоУсловию(ТЗ, "Проверка = Стр.Статья<>П", ВыбСтатья);
Функция УдалитьСтрокиТаблицыПоУсловию(ТЗ, Код, УдалениеСовершено = ложь) Экспорт
	 
	 Всего=ТЗ.Количество();	
	 Для Инд=1 По Всего Цикл	
		 Поз=Всего-Инд;
		 Стр=ТЗ[Поз];
		 Проверка = ложь; 	
		 Попытка		
			 Выполнить(Код);				
		 Исключение	
			 Сообщить(НСтр("ru = '"+ОписаниеОшибки()+"'"), СтатусСообщения.Внимание);		
		 КонецПопытки;
		 
		 Если Проверка = истина Тогда		
			 ТЗ.Удалить(Поз);
			 УдалениеСовершено = Истина;		
		 КонецЕсли;
		 
	 КонецЦикла;
	 
 КонецФункции
 
 Функция ДобавитьКоллекциюВТаблицу(ТЗ, Коллекция) Экспорт
	 //Назначение: Функция добавляет элементы коллекции (это массив строк или таблица значений) в таблицу значений ТЗ
	 //Тестирована: Нет
	 //СтароеИмя: ДобавитьСтрокиВТЗ
	 Для Каждого Эл ИЗ Коллекция Цикл
		 ЗаполнитьЗначенияСвойств(ТЗ.Добавить(), Эл);
	 КонецЦикла;
 КонецФункции
 
 Функция ТаблицуЗначенийВМассивСтрок(ТаблицаЗначений) Экспорт
	 //Таблицу значений в массив
	 
	 НашМассив = Новый Массив;
	 Для Каждого СтрокаТаблицы из ТаблицаЗначений Цикл
		 НашаСтруктура = Новый Структура;
		 Счетчик = 0;
		 Для Каждого СтрокаСтруктуры из СтрокаТаблицы Цикл
			 Если НЕ ТипЗнч(СтрокаСтруктуры) = Тип(ТаблицаЗначений) тогда
				 НашаСтруктура.Вставить(ТаблицаЗначений.Колонки[Счетчик].Имя,СтрокаТаблицы[Счетчик]);
			 Иначе
				 НашаСтруктура.Вставить(ТаблицаЗначений.Колонки[Счетчик].Имя,ТаблицуЗначенийВМассивСтрок(СтрокаСтруктуры));
			 КонецЕсли;
			 Счетчик = Счетчик + 1;
		 КонецЦикла;
		 НашМассив.Добавить(НашаСтруктура);
	 КонецЦикла;
	 Возврат(НашМассив);
 КонецФункции 
 
 Функция КоллекцияВТаблицуЗначений(Коллекция, Поля = Неопределено, ИсхТЗ = Неопределено) Экспорт
	 //Назначение: Копирует коллекцию в новую таблицу
	 //СтароеИмя: МассивСтрокВТаблицуЗначений
	 //Описание: 
	 //$ИсхТЗ: Исходная таблица значений (описывает структуру колонок)
	 //$Коллекция: Коллекция
	 //$Поля: Массив полей
	 Перем ТЗ;
	 
	 Если ИсхТЗ = Неопределено Тогда
		 ТЗ = Новый ТаблицаЗначений();
	 Иначе
		 ТЗ = СкопироватьКолонкиТаблицы(ИсхТЗ, Поля);
	 КонецЕсли;
	 
	 Если Поля = Неопределено Тогда
		 Для Каждого Эл Из Коллекция Цикл
			 Для Каждого Колонка Из ТЗ.Колонки Цикл
				 ЗаполнитьЗначенияСвойств(ТЗ.Добавить(), Эл);
			 КонецЦикла;
		 КонецЦикла;
	 Иначе
		 Для Каждого Поле Из Поля Цикл
			 ТЗ.Колонки.Добавить(Поле);
		 КонецЦикла;
		 
		 Для Каждого Эл Из Коллекция Цикл
			 НСтр = ТЗ.Добавить();
			 Для Каждого Поле Из Поля Цикл
				 НСтр[Поле] = Коллекция[Поле];
			 КонецЦикла;
		 КонецЦикла;
	 КонецЕсли;
	 
	 Возврат ТЗ;
 КонецФункции
 
  
 ////////////////////////////////////////////////////////////////////////////////
 // ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
 //
 Функция НайтиСтрокиССортировкой(ТЗ, Структура) Экспорт
	 М = ТЗ.НайтиСтроки(Структура);
	 ПослеНайтиСтроки(М, ТЗ);
	 Возврат М;
 КонецФункции
 
 Процедура ПослеНайтиСтроки(М, ТЗ = Неопределено) 
	 Если М.Количество() = 0 Тогда Возврат; КонецЕсли;
	 Если ТЗ = Неопределено Тогда ТЗ = М[0].Владелец(); КонецЕсли;
	 ТЗ2 = Новый ТаблицаЗначений();
	 ТЗ2.Колонки.Добавить("Индекс");
	 ТЗ2.Колонки.Добавить("Строка");	
	 Для Каждого Эл ИЗ М Цикл  НСтр = ТЗ2.Добавить(); НСтр.Индекс = ТЗ.Индекс(Эл); НСтр.Строка = Эл; КонецЦикла;               	   
	 ТЗ2.Сортировать("Индекс");
	 М.Очистить();
	 Для Каждого Стр2 ИЗ ТЗ2 Цикл М.Добавить(Стр2.Строка); КонецЦикла;                 
 КонецПроцедуры
  
 // Осуществляет проверку заполненности проверяемых реквизитов.
 //
 // Параметры:
 // Объект               - ДокументОбъект, СправочникОбъект - Проверяемый объект.
 // ПроверяемыеРеквизиты - Массив - массив проверяемых реквизитов.
 //
 // Возвращаемое значение:
 // Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь
 //
 Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, ПроверяемыеРеквизиты) Экспорт
	 
	 Для Каждого Реквизит Из ПроверяемыеРеквизиты Цикл
		 
		 ПозицияТочки = Найти(Реквизит,".");
		 
		 Если ПозицияТочки > 0 Тогда
			 
			 ДлинаСтроки       = СтрДлина(Реквизит);
			 ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			 ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			 
			 Для Каждого ТекСтрока Из Объект[ИмяТабличнойЧасти] Цикл
				 
				 Если Не ЗначениеЗаполнено(ТекСтрока[ИмяРеквизита]) Тогда
					 
					 Возврат Истина;
					 
				 КонецЕсли;
				 
			 КонецЦикла;
			 
		 Иначе
			 
			 Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				 
				 Возврат Истина;
				 
			 КонецЕсли;
			 
		 КонецЕсли;
		 
	 КонецЦикла;
	 
	 Возврат Ложь;
	 
 КонецФункции
 
 // Осуществляет проверку заполненности проверяемых реквизитов.
 //
 // Параметры:
 // Документ           - ДокументСсылка - Документ, на основании которого осуществляется ввод
 // Статус             - Статус документ, на основании которого осуществляется ввод
 // ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
 // ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
 //
 Процедура ПроверитьВозможностьВводаНаОсновании(Документ, Статус = Неопределено, ЕстьОшибкиПроведен = Ложь, ЕстьОшибкиСтатус = Ложь, МассивДопустимыхСтатусов = Неопределено) Экспорт
	 
	 Если ЕстьОшибкиПроведен Тогда
		 
		 ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа невозможен.'");
		 ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		 
		 ВызватьИсключение ТекстОшибки;
		 
	 ИначеЕсли ЕстьОшибкиСтатус Тогда
		 
		 Если МассивДопустимыхСтатусов = Неопределено Тогда
			 ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании невозможен.'");
		 ИначеЕсли ТипЗнч(МассивДопустимыхСтатусов) = Тип("Массив") Тогда
			 
			 ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании возможен в %СтрокаДопустимыхСтатусов%.'");
			 СтрокаДопустимыхСтатусов = "";
			 
			 Для Каждого ДопустимыйСтатус Из МассивДопустимыхСтатусов Цикл
				 СтрокаДопустимыхСтатусов = СтрокаДопустимыхСтатусов + """"+ ДопустимыйСтатус + """, ";
			 КонецЦикла;
			 
			 СтрокаДопустимыхСтатусов = Лев(СтрокаДопустимыхСтатусов, СтрДлина(СтрокаДопустимыхСтатусов)-2);
			 
			 Если МассивДопустимыхСтатусов.Количество() = 0 Тогда
				 ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании невозможен.'");
			 ИначеЕсли МассивДопустимыхСтатусов.Количество() = 1 Тогда
				 ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании возможен только в статусе %СтрокаДопустимыхСтатусов%.'");
				 ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			 Иначе
				 ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании возможен только в статусах %СтрокаДопустимыхСтатусов%.'");
				 ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			 КонецЕсли;
			 
		 КонецЕсли;
		 
		 ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		 ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Статус%",   Статус);
		 
		 ВызватьИсключение ТекстОшибки;
		 
	 КонецЕсли;
	 
 КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()
 
 // Осуществляет проверку заполненности проверяемых реквизитов.
 //
 // Параметры:
 // ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
 //
 Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое) Экспорт
	 
	 Если ЕстьОшибкиТиповое Тогда
		 
		 ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения с клиентом невозможен.'");
		 
		 ВызватьИсключение ТекстОшибки;
		 
	 КонецЕсли;
	 
 КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()
 
 // Устанавливает или сбрасывает флаг Согласован у справочника.
 // Вызывается из процедуры ПередЗаписью документа.
 //
 // Параметры:
 // ДокументОбъект     - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
 // СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
 //
 Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	 
	 // Справочник не имеет статуса
	 Если СтатусНеСогласован = Неопределено Тогда
		 
		 Если Не СправочникОбъект.Согласован Тогда
			 СправочникОбъект.Согласован = Истина;
		 КонецЕсли;
		 
		 // Справочник имеет статус, в котором проведенный справочник не согласован
	 Иначе
		 
		 Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			 СправочникОбъект.Согласован = Ложь;
		 ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			 СправочникОбъект.Согласован = Истина;
		 КонецЕсли;
		 
	 КонецЕсли;
	 
 КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()
 
 // Устанавливает или сбрасывает флаг Согласован у документа.
 // Вызывается из процедуры ПередЗаписью документа.
 //
 // Параметры:
 // ДокументОбъект     - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
 // РежимЗаписи        - Режим записи документа
 // СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
 //
 Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	 
	 Если РежимЗаписи = РежимЗаписиДокумента.Запись Или
		 РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		 
		 Если ДокументОбъект.Согласован Тогда
			 ДокументОбъект.Согласован = Ложь;
		 КонецЕсли;
		 
	 ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		 
		 // Документ не имеет статуса
		 Если СтатусНеСогласован = Неопределено Тогда
			 
			 Если Не ДокументОбъект.Согласован Тогда
				 ДокументОбъект.Согласован = Истина;
			 КонецЕсли;
			 
			 // Документ имеет статус из массива, в которых проведенный документ не согласован
		 ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			 
			 Если ДокументОбъект.Согласован Тогда
				 
				 Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					 
					 Если ДокументОбъект.Статус = ТекСтатус Тогда
						 
						 ДокументОбъект.Согласован = Ложь;
						 Прервать;
						 
					 КонецЕсли;
					 
				 КонецЦикла;
				 
			 Иначе
				 
				 ДокументСогласован = Истина;
				 
				 Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					 
					 Если ДокументОбъект.Статус = ТекСтатус Тогда
						 ДокументСогласован = Ложь;
					 КонецЕсли;
					 
				 КонецЦикла;
				 
				 Если ДокументСогласован Тогда
					 ДокументОбъект.Согласован = Истина;
				 КонецЕсли;
				 
			 КонецЕсли;
			 
			 // Документ имеет статус, в котором проведенный документ не согласован
		 Иначе
			 
			 Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				 ДокументОбъект.Согласован = Ложь;
			 ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				 ДокументОбъект.Согласован = Истина;
			 КонецЕсли;
			 
		 КонецЕсли;
		 
	 КонецЕсли;
	 
 КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()
 
 // Функция заполняет структуру значениями перечисления
 //
 // Параметры
 //  ИмяПеречисления  - строка - имя перечисления
 //  Включать  пустую ссылку  - булево - добавлять ли в структуру значение пустой ссылки
 //                 
 // Возвращаемое значение:
 //   СтруктураВозврата   - Структура содержащая значения перечисления,
 //                         в том числе пустое значение.
 Функция ПолучитьСтруктуруЗначенияПеречисления(ИмяПеречисления, ВключатьПустуюСсылку = ЛОЖЬ) Экспорт
	 
	 СтруктураВозврата   = Новый Структура;
	 Для каждого ЭлементМетаданных Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		 СтруктураВозврата.Вставить(ЭлементМетаданных.Имя,Перечисления[ИмяПеречисления][ЭлементМетаданных.Имя]);
	 КонецЦикла;
	 
	 Если ВключатьПустуюСсылку Тогда
		 СтруктураВозврата.Вставить("ПустаяСсылка",Перечисления[ИмяПеречисления].ПустаяСсылка());
	 КонецЕсли;		
	 
	 Возврат СтруктураВозврата;	
	 
 КонецФункции // ПолучитьСтруктуруЗначенияПеречисления()
 
 // Процедура устанавливает блокировку документа для редактирования.
 //
 // Параметры:
 //	ДокументСсылка - документ, на который устанавливается блокировка
 //	ОтменятьТранзакцию - Булево - Признак необходимости отмены транзакции
 //
 Процедура ЗаблокироватьДокументДляРедактирования(ДокументСсылка, ОтменятьТранзакцию = Ложь) Экспорт
	 
	 Попытка
		 ЗаблокироватьДанныеДляРедактирования(ДокументСсылка);
	 Исключение
		 ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		 НСтр("ru='Не удалось заблокировать %1. %2'"),
		 ДокументСсылка,
		 КраткоеПредставлениеОшибки(ИнформацияОбОшибке())
		 );
		 Если ОтменятьТранзакцию Тогда
			 ОтменитьТранзакцию();
		 КонецЕсли;
		 ВызватьИсключение ТекстОшибки;
	 КонецПопытки;
	 
 КонецПроцедуры // ЗаблокироватьДокументДляРедактирования()
 
 //Отладчик
 Функция Ду(Код = Неопределено, П=Неопределено, П1=Неопределено,  П2=Неопределено, П3=Неопределено, П4=Неопределено)  Экспорт
	 
	 Перем Р;
	 
	 Если Код = Неопределено Тогда
		 Возврат Неопределено;
	 КонецЕсли;
	 
	 Выполнить(Код);
	 
	 Возврат Р;
	 
 КонецФункции
 
 //Работа С Картинками 
 ///////////////////////////////////////////////////////////////////////////////////////////////                                                   
 Функция  СохранитьКартинкуВСправочникФайлы(Адрес, ИмяФайла)  Экспорт 
	 //
	 Если ПустаяСтрока(Адрес) Тогда
		 Картинка = Новый Картинка;
	 Иначе                                                         
		 Картинка = ПолучитьИзВременногоХранилища(Адрес);
	 КонецЕсли;
	 
	 Запрос = Новый Запрос;
	 Запрос.УстановитьПараметр("ПолноеИмяФайла", ИмяФайла) ;
	 
	 Запрос.Текст = "ВЫБРАТЬ
	 |	Файлы.Ссылка
	 |ИЗ
	 |	Справочник.Файлы КАК Файлы
	 |ГДЕ
	 |	Файлы.ПолноеИмяФайла ПОДОБНО &ПолноеИмяФайла";
	 
	 РезультатЗапроса = Запрос.Выполнить().Выбрать();
	 Если РезультатЗапроса.Количество()>0 Тогда
		 РезультатЗапроса.Следующий();
		 СправочникФайл  = РезультатЗапроса.Ссылка;
	 Иначе    		   
		 НовыйСправочникФайл =Справочники.Файлы.СоздатьЭлемент();
		 НовыйСправочникФайл.ПолноеИмяФайла = ИмяФайла;
		 НовыйСправочникФайл.Хранилище = Новый ХранилищеЗначения(Картинка, Новый СжатиеДанных(9));
		 НовыйСправочникФайл.Записать();
		 СправочникФайл = НовыйСправочникФайл.Ссылка;
	 КонецЕсли;
	 
	 Возврат СправочникФайл; 			
 КонецФункции	
