
#Если Клиент Тогда
	
// Процедура вывода текста сообщения в окно сообщений.
//
// Параметры:
//	ТекстПредупреждения - Строка. Текст предупреждения.;
//	Таймаут - Число. Интервал времени в секундах, в течение которого система будет ожидать ответа пользователя;
//	Заголовок - Строка. Заголовок окна.
//
Процедура ВывестиСообщение(ТекстСообщения, Статус = Неопределено, Заголовок = Ложь) Экспорт
	
	// Проверка инициализированности графичесокй подсистемы Front-office.
	Попытка
		ВключенFrontOffice = ПараметрыСеанса.глВключенFrontOffice;
	Исключение
		ВключенFrontOffice = глЗначениеПеременной("глВключенFrontOffice"); 
	КонецПопытки;
	
	Если ВключенFrontOffice = Неопределено Тогда
		ВключенFrontOffice =Истина;	
	КонецЕсли;
	
	Если ВключенFrontOffice Тогда
		FrontOffice.ВывестиСообщение(ТекстСообщения, Статус, Заголовок);
		Возврат;
	КонецЕсли;
	
	// Стандартный механизм.
	Сообщить(ТекстСообщения, Статус);
	
КонецПроцедуры // ВывестиСообщение()


// Процедура вывода на экран окна предупреждения.
//
// Параметры:
//	ТекстПредупреждения - Строка. Текст предупреждения.;
//	Таймаут - Число. Интервал времени в секундах, в течение которого система будет ожидать ответа пользователя;
//	Заголовок - Строка. Заголовок окна.
//
Процедура ВывестиПредупреждение(ТекстПредупреждения, Таймаут = 0, Заголовок = "") Экспорт
	
	
	Попытка
		ВключенFrontOffice = ПараметрыСеанса.глВключенFrontOffice;
	Исключение
		ВключенFrontOffice = глЗначениеПеременной("глВключенFrontOffice"); 
	КонецПопытки;
	
	Если ВключенFrontOffice = Неопределено Тогда
		ВключенFrontOffice =Истина;	
	КонецЕсли;
	// Проверка инициализированности графичесокй подсистемы Front-office.
	Если ВключенFrontOffice Тогда
        FrontOffice.ВывестиПредупреждение(ТекстПредупреждения, Таймаут, Заголовок);
		Возврат;
	КонецЕсли;
	
	// Стандартный механизм.
	Предупреждение(ТекстПредупреждения, Таймаут, Заголовок);
	
КонецПроцедуры // ВывестиПредупреждение()
	
// Процедура вывода на экран окна восклицания.
//
// Параметры:
//	ТекстПредупреждения - Строка. Текст предупреждения.;
//	Таймаут - Число. Интервал времени в секундах, в течение которого система будет ожидать ответа пользователя;
//	Заголовок - Строка. Заголовок окна.
//
Процедура ВывестиВосклицание(ТекстПредупреждения, Таймаут = 0, Заголовок = "") Экспорт
	
	Попытка
		ВключенFrontOffice = ПараметрыСеанса.глВключенFrontOffice;
	Исключение
		ВключенFrontOffice = глЗначениеПеременной("глВключенFrontOffice"); 
	КонецПопытки;
	
	Если ВключенFrontOffice = Неопределено Тогда
		ВключенFrontOffice =Истина;	
	КонецЕсли;
	 //Проверка инициализированности графичесокй подсистемы Front-office.
	Если ВключенFrontOffice Тогда
		FrontOffice.ВывестиВосклицание(ТекстПредупреждения, Таймаут, Заголовок);
		Возврат;
	КонецЕсли;
	
	// Стандартный механизм.
	Предупреждение(ТекстПредупреждения, Таймаут, Заголовок);
	
КонецПроцедуры // ВывестиВосклицание()

// Процедура вывода на экран окна ошибки.
//
// Параметры:
//	ТекстПредупреждения - Строка. Текст предупреждения.;
//	Таймаут - Число. Интервал времени в секундах, в течение которого система будет ожидать ответа пользователя;
//	Заголовок - Строка. Заголовок окна.
//
Процедура ВывестиОшибку(ТекстПредупреждения, Таймаут = 0, Заголовок = "") Экспорт
	
	ТекстПредупреждения = СформироватьТекстСообщения(ТекстПредупреждения);
	Попытка
		ВключенFrontOffice = ПараметрыСеанса.глВключенFrontOffice;
	Исключение
		ВключенFrontOffice = глЗначениеПеременной("глВключенFrontOffice"); 
	КонецПопытки;
	
	Если ВключенFrontOffice = Неопределено Тогда
		ВключенFrontOffice =Истина;	
	КонецЕсли;
	
	// Проверка инициализированности графичесокй подсистемы Front-office.
	Если ВключенFrontOffice Тогда
        FrontOffice.ВывестиОшибку(ТекстПредупреждения, Таймаут, Заголовок);
		Возврат;
	КонецЕсли;
	
	// Стандартный механизм.
	Предупреждение(ТекстПредупреждения, Таймаут, Заголовок);
	
КонецПроцедуры // ВывестиОшибку()
      
// Функция вывода на экран окна вопроса.
//
// Параметры:
//	ТекстВопроса - Строка. Текст задаваемого вопроса;
//	Режим - РежимДиалогаВопрос. Задает состав кнопок диалога и возможные варианты ответов;
//	Таймаут - Число. Интервал времени в секундах, в течение которого система будет ожидать ответа пользователя;
//	КнопкаПоУмолчанию - КодВозвратаДиалога. Определяет кнопку, которая должна быть назначена кнопкой по умолчанию;
//	Заголовок - Строка. Заголовок окна.
//
// Возвращаемое значение:
//	КодВозвратаДиалога. В зависимости от реакции пользователя возвращается одно из значений системного перечисления.
//
Функция ВывестиВопрос(ТекстВопроса, Режим, Таймаут = 0, КнопкаПоУмолчанию = Неопределено, Заголовок = "") Экспорт
	Попытка
		ВключенFrontOffice = ПараметрыСеанса.глВключенFrontOffice;
	Исключение
		ВключенFrontOffice = глЗначениеПеременной("глВключенFrontOffice"); 
	КонецПопытки;
	
	Если ВключенFrontOffice = Неопределено Тогда
		ВключенFrontOffice =Истина;	
	КонецЕсли;
	
	// Проверка инициализированности графичесокй подсистемы Front-office.
	Если ВключенFrontOffice Тогда
		Возврат FrontOffice.ВывестиВопрос(ТекстВопроса, Режим, Таймаут, КнопкаПоУмолчанию, Заголовок);
	КонецЕсли;
	
	// Стандартный механизм.
	Возврат Вопрос(ТекстВопроса, Режим, Таймаут, КнопкаПоУмолчанию, Заголовок);
	
КонецФункции // ВывестиВопрос()

#КонецЕсли


// Записывает набор констант, сравнивая его с эталонным набором
// Записываются только те константы, которые были изменены относительно эталонного набора
//
// Параметры: 
//  НаборКонстант  - Набор констант
//  ЭталонныйНабор - Эталонный набор констант
//  Модифицированность - Устанавливается в истину, если операция выполнена успешно
//
// Возвращаемое значение:
//  Истина - операция выполнена, ложь - иначе.
//
Функция ЗаписатьНаборКонстант(НаборКонстант, ЭталонныйНабор, Модифицированность = Истина) Экспорт
	
	ЗаписываемыеКонстанты = "";
	Для каждого Константа Из Метаданные.Константы Цикл
		
		ИмяКонстанты = Константа.Имя;
		
		ЗначениеНабора    = ЗначениеВСтрокуВнутр(НаборКонстант[ИмяКонстанты]);
		ЭталонноеЗначение = ЗначениеВСтрокуВнутр(ЭталонныйНабор[ИмяКонстанты]);
		
		Если Не ЗначениеНабора = ЭталонноеЗначение Тогда
			
			ТекущееЗначение   = ЗначениеВСтрокуВнутр(Константы[ИмяКонстанты].Получить());
			
			Если Не ЗначениеНабора = ТекущееЗначение Тогда
				ЗаписываемыеКонстанты = ЗаписываемыеКонстанты + ?(ПустаяСтрока(ЗаписываемыеКонстанты), "", ", ") + ИмяКонстанты;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ЗаписываемыеКонстанты) Тогда
		
		ЗаписываемыйНабор = Константы.СоздатьНабор(ЗаписываемыеКонстанты);
		ЗаполнитьЗначенияСвойств(ЗаписываемыйНабор, НаборКонстант, ЗаписываемыеКонстанты);
		
		Попытка
			ЗаписываемыйНабор.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		НаборКонстант.Прочитать();
		ЗаполнитьЗначенияСвойств(ЭталонныйНабор, НаборКонстант);
		
	КонецЕсли; 
	
	Модифицированность = Ложь;
	Возврат Истина;
	
КонецФункции


// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Неопределено") Тогда
		Возврат Неопределено;
	ИначеЕсли ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Определяет заполнено ли переданное значение
// В качестве значения, допускается передавать только значение с примитивным типом(Булево, Дата, Строка, Число, Null, Неопределено),
// с типом "Режим проведения документа" или ссылочным типом.
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНЕЗаполнено(Значение) Экспорт

	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
	//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
	// Для остальных будем считать значение пустым, если оно равно
	// дефолтному значению своего типа
	Иначе
		Попытка
			Если Значение = Новый(ТипЗначения) Тогда
				Результат = Истина;
			КонецЕсли; 
		Исключение
			Результат = Ложь;
		КонецПопытки;
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // НЕ ЗначениеЗаполнено()


Функция БезопасноПолучитьЗначение(Значение) Экспорт

	Попытка
		А = Вычислить("Значение");
		Возврат А; 
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции



// Преобразует таблицу значений в дерево значений, группируя значения по колонкам, формирование итога по строкам
Функция ТаблицуЗначенийВДеревоСГруппировкой(ТаблицаРезультатов, знач ГруппировочныеКолонки= "",знач КолонкиИтогов = "") экспорт
	
	ДеревоРезультатов  = Новый ДеревоЗначений();
	Для каждого Колонка из ТаблицаРезультатов.Колонки Цикл
		ДеревоРезультатов.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
	КонецЦикла; 
	
	Если ПустаяСтрока(ГруппировочныеКолонки) Тогда
		Для каждого СтрокаТаблицы Из ТаблицаРезультатов Цикл
			СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
			Для каждого Колонка из ДеревоРезультатов.Колонки Цикл
				СтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя]
			КонецЦикла; 
		КонецЦикла; 
		
		Возврат ДеревоРезультатов;
	КонецЕсли;
	
	ТаблицаГруппировок = ТаблицаРезультатов.Скопировать();
	ТаблицаГруппировок.Свернуть(ГруппировочныеКолонки,КолонкиИтогов);

	ИндексКолонкиРодитель = ДеревоРезультатов.Колонки.Индекс(ДеревоРезультатов.Колонки.Найти("Родитель"));
	
	Для каждого СтрокаТаблицы Из ТаблицаГруппировок Цикл
		СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
		Для каждого Колонка из ТаблицаГруппировок.Колонки Цикл
			Если (НРег(Колонка.Имя) = "родитель") Тогда
				СтрокаДерева.Установить(ИндексКолонкиРодитель, СтрокаТаблицы[Колонка.Имя]);
			Иначе
				СтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя];
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла; 
	//Для каждого СтрокаТаблицы Из ТаблицаГруппировок Цикл
	//	СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
	//	Для каждого Колонка из ТаблицаГруппировок.Колонки Цикл
	//		СтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя]
	//	КонецЦикла; 
	//КонецЦикла; 
	
	ЗначенияОтбора = Новый Структура(ГруппировочныеКолонки);
	Для каждого СтрокаДерева из  ДеревоРезультатов.Строки Цикл
		//Формирование структуры отбора
		Для каждого ПараметрОтбора Из ЗначенияОтбора Цикл
			ЗначенияОтбора.Вставить(ПараметрОтбора.Ключ, СтрокаДерева[ПараметрОтбора.Ключ]);
		КонецЦикла; 
		
		//Поиск и заполнение подчиненными колонками
		МассивПодчиненныйхСтрок = ТаблицаРезультатов.НайтиСтроки(ЗначенияОтбора);
		Для каждого СтрокаТаблицы Из МассивПодчиненныйхСтрок Цикл
			ПодчиненнаяСтрокаДерева = СтрокаДерева.Строки.Добавить();
			Для каждого Колонка из ДеревоРезультатов.Колонки Цикл
				ПодчиненнаяСтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя];
			КонецЦикла; 
		КонецЦикла; 
	КонецЦикла;
		
	Возврат ДеревоРезультатов;
КонецФункции



// Преобразует таблицу значений в дерево значений, группируя значения по колонкам, формирование итога по строкам
Функция ТаблицуЗначенийВДеревоЗначений(ТаблицаЗначений, Ссылка = "", Родитель = "", ДеревоЗначений = Неопределено, ДополнитьДерево=Ложь) экспорт
	  
	// Дерево значений.
	Если НЕ(ДополнитьДерево) Тогда
		Если (ДеревоЗначений = Неопределено) Тогда
			ДеревоЗначений = Новый ДеревоЗначений();
			НовоеДерево = Истина;
		Иначе
			ДеревоЗначений.Строки.Очистить();
			ДеревоЗначений.Колонки.Очистить();
		КонецЕсли;
		Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			ДеревоЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
		КонецЦикла;
	КонецЕсли;
	
	// Сортировка.
	УпорядоченнаяТаблица = ТаблицаЗначений.Скопировать();
	Для ИндексСтроки = 0 По УпорядоченнаяТаблица.Количество() - 1 Цикл
		СтрокаТаблицыЗначений = УпорядоченнаяТаблица.Получить(ИндексСтроки);
		РодительВТаблицеЗначений = УпорядоченнаяТаблица.Найти(СтрокаТаблицыЗначений[Родитель], Ссылка);
		Если (РодительВТаблицеЗначений = Неопределено) Тогда
			ИндексРодителя = -1;
		Иначе
			ИндексРодителя = УпорядоченнаяТаблица.Индекс(РодительВТаблицеЗначений);
		КонецЕсли;
		Если (ИндексСтроки < ИндексРодителя) Тогда
			УпорядоченнаяТаблица.Сдвинуть(РодительВТаблицеЗначений, ИндексСтроки - ИндексРодителя);
			ИндексСтроки = ИндексСтроки - 1;
		КонецЕсли;
	КонецЦикла;
	
	// Перенос данных.
	КоличетсвоКолонок = ДеревоЗначений.Колонки.Количество();
	Для Каждого СтрокаТаблицыЗначений Из УпорядоченнаяТаблица Цикл
		РодительВДеревеЗначений = ДеревоЗначений.Строки.Найти(СтрокаТаблицыЗначений[Родитель], Ссылка, Истина); 
		Если (РодительВДеревеЗначений = Неопределено) Тогда
			РодительВДеревеЗначений = ДеревоЗначений;
		КонецЕсли;
		
		СтрокаДереваЗначений = РодительВДеревеЗначений.Строки.Добавить();
		Для ИндексКолонки = 0 По КоличетсвоКолонок - 1 Цикл
			СтрокаДереваЗначений.Установить(ИндексКолонки, СтрокаТаблицыЗначений.Получить(ИндексКолонки)); 
		КонецЦикла; 
		
				
	КонецЦикла;
		
	Возврат ДеревоЗначений;
	
КонецФункции

Функция ТаблицуЗначенийВДеревоЗначенийСГруппировкой(ТаблицаЗначений, ГруппировочныеКолонки, КолонкаИерархии, ДеревоЗначений = Неопределено, ИсключитьИзСортировки = Неопределено) Экспорт
	
	// Дерево значений.
	Если (ДеревоЗначений = Неопределено) Тогда
		ДеревоЗначений = Новый ДеревоЗначений();
	Иначе
		ДеревоЗначений.Строки.Очистить();
		ДеревоЗначений.Колонки.Очистить();
	КонецЕсли;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если (Колонка.Имя = КолонкаИерархии) Тогда 
			ДеревоЗначений.Колонки.Добавить(Колонка.Имя,Неопределено,Колонка.Заголовок,Колонка.Ширина);
		Иначе
			ДеревоЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
		КонецЕсли;
	КонецЦикла;
	
	// Без группировка.
	Если ПустаяСтрока(ГруппировочныеКолонки) Тогда
		Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
			СтрокаДереваЗначений = ДеревоЗначений.Строки.Добавить();
			Для Каждого Колонка из ТаблицаЗначений.Колонки Цикл
				СтрокаДереваЗначений[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя]
			КонецЦикла; 
		КонецЦикла; 
		
		Возврат ДеревоЗначений;
	КонецЕсли;
	
	// Структура сртировки.
	СтрутураИсключаемойСортировки = Новый Структура(Строка(ИсключитьИзСортировки));
	
	// Структура группировки.
	СтрутураГруппировок = Новый Структура; МассивГруппировок = Новый Массив; СтрокаГруппировок = СтрЗаменить(ГруппировочныеКолонки, ",", Символы.ПС); КоличествоГруппировок = СтрЧислоСтрок(СтрокаГруппировок); СортировочныеКолонки = Строка(Неопределено);
	Для Индекс = 1 По КоличествоГруппировок Цикл
		Группировка = СтрПолучитьСтроку(СтрокаГруппировок, Индекс);
		МассивГруппировок.Добавить(Группировка); 
		СтрутураГруппировок.Вставить(Группировка);
		Если Не СтрутураИсключаемойСортировки.Свойство(Группировка) Тогда
			Если ПустаяСтрока(СортировочныеКолонки) Тогда
				СортировочныеКолонки = Группировка;
			Иначе
				СортировочныеКолонки = СортировочныеКолонки + "," + Группировка;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Группировка.
	ТаблицаГруппировок = ТаблицаЗначений.Скопировать();
	ТаблицаГруппировок.Свернуть(ГруппировочныеКолонки);
	Если Не ПустаяСтрока(СортировочныеКолонки) Тогда
		ТаблицаГруппировок.Сортировать(СортировочныеКолонки);
	КонецЕсли;

	// Структура дерева.
	СтрокиДереваЗначений = Новый Соответствие;
	Для Каждого СтрокаТаблицы Из ТаблицаГруппировок Цикл
		ЗначенияОтбора = Новый Структура(ГруппировочныеКолонки);
		СтрокаДереваЗначений = ДеревоЗначений.Строки;
		Для Каждого Группировка Из СтрутураГруппировок Цикл
			ЗначенияОтбора[Группировка.Ключ] = СтрокаТаблицы[Группировка.Ключ];
			
			Если (Группировка.Значение = Неопределено) Или (Не Группировка.Значение[КолонкаИерархии] = СтрокаТаблицы[Группировка.Ключ]) Тогда
				СтрокаДереваЗначений = СтрокаДереваЗначений.Добавить();
			Иначе
				СтрокаДереваЗначений = Группировка.Значение.Строки;
				Продолжить;
			КонецЕсли;
			
			СтрокаДереваЗначений[КолонкаИерархии] = СтрокаТаблицы[Группировка.Ключ];
			СтрутураГруппировок[Группировка.Ключ] = СтрокаДереваЗначений;
			
			Обнуление = Ложь; Для Каждого ПеребираемаяГруппировка Из СтрутураГруппировок Цикл
				Если Обнуление Тогда
					СтрутураГруппировок[ПеребираемаяГруппировка.Ключ] = Неопределено;
				Иначе
					СтрокаДереваЗначений[ПеребираемаяГруппировка.Ключ] = СтрокаТаблицы[Группировка.Ключ];
					Обнуление = (ПеребираемаяГруппировка.Ключ = Группировка.Ключ);
				КонецЕсли;
			КонецЦикла;

			СтрокаДереваЗначений = СтрокаДереваЗначений.Строки;
		КонецЦикла;
		СтрокиДереваЗначений.Вставить(СтрокаДереваЗначений.Родитель, ЗначенияОтбора);
	КонецЦикла; 

	// Перенос данных.
	Для Каждого СтрокаДерева Из СтрокиДереваЗначений Цикл
		ЗначенияОтбора = СтрокаДерева.Значение; СтрокаДерева = СтрокаДерева.Ключ;
		МассивПодчиненныйхСтрок = ТаблицаЗначений.НайтиСтроки(ЗначенияОтбора);
		Для Каждого СтрокаТаблицы Из МассивПодчиненныйхСтрок Цикл
			ПодчиненнаяСтрокаДерева = СтрокаДерева.Строки.Добавить();
			Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
				ПодчиненнаяСтрокаДерева[Колонка.Имя] = СтрокаТаблицы[Колонка.Имя];
			КонецЦикла; 
		КонецЦикла; 
	КонецЦикла;
		
	Возврат ДеревоЗначений;
	
КонецФункции


Функция ТаблицуЗначенийРазделитьПоОтбору(ТаблицаЗначений, СтруктураОтбора, ТаблицаУдовлетворяетОтбору = Неопределено, ТаблицаНеУдовлетворяетОтбору = Неопределено) экспорт
	
	// Перенос данных.
	ТаблицаУдовлетворяетОтбору = ТаблицаЗначений.Скопировать(СтруктураОтбора);
	ТаблицаНеУдовлетворяетОтбору = ТаблицаЗначений.Скопировать();
	
	// Удаление данных.
	Для Каждого СтрокаТаблицы Из ТаблицаНеУдовлетворяетОтбору.НайтиСтроки(СтруктураОтбора) Цикл
		ТаблицаНеУдовлетворяетОтбору.Удалить(СтрокаТаблицы);
	КонецЦикла; 
	
	Возврат Новый Структура("ТаблицаИсходная,ТаблицаУдовлетворяетОтбору,ТаблицаНеУдовлетворяетОтбору", ТаблицаЗначений, ТаблицаУдовлетворяетОтбору, ТаблицаНеУдовлетворяетОтбору);
	
КонецФункции // ТаблицуЗначенийРазделитьПоОтбору()

Функция ТаблицуЗначенийПолучитьВРазрезе(ТаблицаЗначений, ГруппировочныеКолонки, КолонкиИтогов = Неопределено) Экспорт
	
	// Перенос данных.
	ТаблицаЗначенийВРазрезе = ТаблицаЗначений.Скопировать();
	
	// Группировка.
	ТаблицаЗначенийВРазрезе.Свернуть(ГруппировочныеКолонки, КолонкиИтогов);
	
	// Результат.
	Возврат ТаблицаЗначенийВРазрезе;
	
КонецФункции // ТаблицуЗначенийРазделитьПоОтбору()

Функция ДеревоЗначенийВТаблицуЗначений(ДеревоЗначений, КорневаяСтрока = Неопределено, ВключаяПодчиненые = Истина, Колонки = Неопределено, СтруктураОтбора = Неопределено, ТаблицаЗначений = Неопределено) Экспорт
	
	// Дерево значений.
	Если (ТаблицаЗначений = Неопределено) Тогда
		ТаблицаЗначений = Новый ТаблицаЗначений();
	Иначе
		ТаблицаЗначений.Очистить();
		ТаблицаЗначений.Колонки.Очистить();
	КонецЕсли;
	Для Каждого Колонка Из ДеревоЗначений.Колонки Цикл
		ТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
	КонецЦикла;
	
	// Только необходимые колонки.
	Если Не ПустаяСтрока(Колонки) Тогда
		ТаблицаЗначений.Свернуть(Колонки);
	КонецЕсли;
	
	// Корневая строка.
	Если (КорневаяСтрока = Неопределено) Тогда
		КорневаяСтрока = ДеревоЗначений;
	КонецЕсли;
		
	// Нисходящий обход дерева.
	СписокПодчиненных = Новый СписокЗначений();
	СписокПодчиненных.Добавить(КорневаяСтрока);

	Для Каждого СтрокаВладелец Из СписокПодчиненных Цикл
		СтрокаВладелец = СтрокаВладелец.Значение;	// Наепка - друг чекиста ;)
		
		Для Каждого СтрокаВладельца Из СтрокаВладелец.Строки Цикл
			Если ВключаяПодчиненые И (Не СтрокаВладельца.Строки.Количество() = 0) Тогда
				СписокПодчиненных.Добавить(СтрокаВладельца);
			КонецЕсли;
			
			// Перенос данных.
			ЗаполнитьЗначенияСвойств(ТаблицаЗначений.Добавить(), СтрокаВладельца);
		КонецЦикла;
	
	КонецЦикла;
	
	// Отбор.
	Если (Не СтруктураОтбора = Неопределено) Тогда
		МассивСтрокПоОтбору = ТаблицаЗначений.НайтиСтроки(СтруктураОтбора);
		Если Булево(МассивСтрокПоОтбору.Количество()) Тогда
			Индекс = ТаблицаЗначений.Количество() - 1;
			Пока (Индекс >= 0) Цикл
				Если (МассивСтрокПоОтбору.Найти(ТаблицаЗначений.Получить(Индекс)) = Неопределено) Тогда
					ТаблицаЗначений.Удалить(Индекс);	
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		Иначе
			ТаблицаЗначений.Очистить();	
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТаблицаЗначений;
	
КонецФункции // ДеревоЗначенийВТаблицуЗначений()

  
Процедура ДополнитьКолонкиТаблицыЗначений(ТаблицаБазовая,ТаблицаДополнений) Экспорт
	
	Для каждого Колонка из ТаблицаДополнений.Колонки Цикл

		Если Не(ТаблицаБазовая.Колонки.Найти(Колонка.Имя) = Неопределено) тогда
			//Колонка уже есть
			Продолжить;
		КонецЕсли;

		ТаблицаБазовая.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);

	КонецЦикла;

КонецПроцедуры


 // Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
					 
	//ТекстСообщения = СтрЗаменить(ТекстСообщения, Символы.ПС + " ", Символы.ПС);
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()




// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#ИначеЕсли Клиент Тогда 
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ВывестиСообщение(Заголовок, , Истина);
			Заголовок = "";
		КонецЕсли;
		
		____Сообщение(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

// Мирошниченоко Игорь 04.01.2012 15:08:58
//
Функция ВидимостьВторойФормы() Экспорт
	Возврат УправлениеПользователями.ПолучитьЗначениеПрава(ПланыВидовХарактеристик.ПраваПользователей.РазрешитьПросмотрВторойФормы);  
КонецФункции

Процедура СообщитьОбНезаполненомРеквизитеСправочника(Справочник, Знач Реквизит, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не Справочник.Метаданные().Реквизиты.Найти(Реквизит) = Неопределено) Тогда
		Реквизит = Справочник.Метаданные().Реквизиты.Найти(Реквизит).Синоним;
	КонецЕсли;
	ТекстСообщения = НСтр("ru='Перед записью элемента справочника «';uk='Перед записом элемента довідника «'")  + Справочник.Метаданные().Синоним + НСтр("ru='» необходимо заполнить реквизит «';uk='» необхідно заповнити реквізит «'") + Реквизит + "».";
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры

Процедура СообщитьОбНеуникальностиРеквизитаСправочника(Справочник, Знач Реквизит, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не Справочник.Метаданные().Реквизиты.Найти(Реквизит) = Неопределено) Тогда
		Реквизит = Справочник.Метаданные().Реквизиты.Найти(Реквизит).Синоним;
	КонецЕсли;
	
	 
	ТекстСообщения = НСтр("ru='Элемент справочника «';uk='Елемент довідника «'") + Справочник.Метаданные().Синоним + НСтр("ru='» с данным значением реквизита «';uk='» з даним значенням реквізиту «'") + Реквизит + НСтр("ru='» уже существует.';uk='» вже існує.'");
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры


Процедура СообщитьОбНезаполненомРеквизитеДокумента(Документ, Знач Реквизит, Отказ = Ложь, Заголовок = "", Статус = Неопределено, Предупреждением = Ложь) Экспорт

	Если (Не Документ.Метаданные().Реквизиты.Найти(Реквизит) = Неопределено) Тогда
		Реквизит = Документ.Метаданные().Реквизиты.Найти(Реквизит).Синоним;
	КонецЕсли;
	ТекстСообщения = НСтр("ru='Перед записью документа «';uk='Перед записом документа «'") + Документ.Метаданные().Синоним + НСтр("ru='» необходимо заполнить реквизит «';uk='» необхідно заповнити реквізит «'") + Реквизит + "».";
	
	Если Предупреждением Тогда
		Отказ = Истина; ____Предупреждение(ТекстСообщения, , Заголовок); Возврат;
	КонецЕсли;
		
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры // СообщитьОбНезаполненомРеквизитеДокумента()


Процедура СообщитьОбНезаполненойТабличнойЧастиДокумента(Документ, Знач ТабличнаяЧасть, Отказ = Ложь, Заголовок = "", Статус = Неопределено, Предупреждением = Ложь) Экспорт

	Если (Не Документ.Метаданные().ТабличныеЧасти.Найти(ТабличнаяЧасть) = Неопределено) Тогда
		ТабличнаяЧасть = Документ.Метаданные().ТабличныеЧасти.Найти(ТабличнаяЧасть).Синоним;
	КонецЕсли;
	
	ТекстСообщения = НСтр("ru='Перед записью документа «';uk='Перед записом документа «'") + Документ.Метаданные().Синоним + НСтр("ru='» необходимо заполнить табличную часть «';uk='» необхідно заповнити табличну частину «'") + ТабличнаяЧасть + "».";
	
	Если Предупреждением Тогда
		Отказ = Истина; ____Предупреждение(ТекстСообщения, , Заголовок); Возврат;
	КонецЕсли;
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры // СообщитьОбНезаполненойТабличнойЧастиДокумента()


Процедура СообщитьОбНезаполненомРеквизитеТабличнойЧастиДокумента(Документ, Знач ТабличнаяЧасть, Знач Реквизит, НомерСтроки = 0, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не Документ.Метаданные().ТабличныеЧасти.Найти(ТабличнаяЧасть) = Неопределено) Тогда
		Если (Не Документ.Метаданные().ТабличныеЧасти[ТабличнаяЧасть].Реквизиты.Найти(Реквизит) = Неопределено) Тогда
			Реквизит = Документ.Метаданные().ТабличныеЧасти[ТабличнаяЧасть].Реквизиты.Найти(Реквизит).Синоним;
		КонецЕсли;
		ТабличнаяЧасть = Документ.Метаданные().ТабличныеЧасти.Найти(ТабличнаяЧасть).Синоним;
	КонецЕсли;
	
	 
	ТекстСообщения = НСтр("ru='Перед записью документа «';uk='Перед записом документа «'")  + Документ.Метаданные().Синоним + НСтр("ru='» необходимо заполнить реквизит «';uk='» необхідно заповнити реквізит «'") + Реквизит + НСтр("ru='» табличной части «';uk='» табличної частини «'") + ТабличнаяЧасть + "».";
	Если Не ЗначениеНЕЗаполнено(НомерСтроки) Тогда
		ТекстСообщения = ТекстСообщения + " " + НСтр("ru='Номер строки: ';uk='Номер рядка: '") + НомерСтроки + ".";
	КонецЕсли;
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры // СообщитьОбНезаполненомРеквизитеДокумента()


Процедура СообщитьОбНезаполненомРеквизитеПланаВидовХарактеристик(ПланВидовХарактеристик, Знач Реквизит, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не ПланВидовХарактеристик.Метаданные().Реквизиты.Найти(Реквизит) = Неопределено) Тогда
		Реквизит = ПланВидовХарактеристик.Метаданные().Реквизиты.Найти(Реквизит).Синоним;
	КонецЕсли;
	
	ТекстСообщения = "Перед записью элемента плана видов характеристик «" + ПланВидовХарактеристик.Метаданные().Синоним + "» необходимо заполнить реквизит «" + Реквизит + "».";
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры


Процедура СообщитьОбОшибкеЗапеисиРегистра(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено, Регистр = Неопределено, Регистратор = Неопределено) Экспорт

	Если (Не Регистр = Неопределено) Тогда
		ТекстСообщенияExt = "Не возможно изменить данные регистра «" + Регистр.Метаданные().Синоним + "»";
		
		Если (Не Регистратор = Неопределено) Тогда
			ТекстСообщенияExt = ТекстСообщенияExt + " связанные с регистратором «" + Регистратор + "»";
		КонецЕсли;
		
		Если ПустаяСтрока(ТекстСообщения) Тогда
			ТекстСообщения = ТекстСообщенияExt + ".";
		Иначе
			ТекстСообщения = ТекстСообщенияExt + ":" + ТекстСообщения;
		КонецЕсли;
	КонецЕсли;
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);
	
КонецПроцедуры // СообщитьОбОшибкеЗапеисиРегистра()

Процедура СообщитьОбНезаполненомРесурсеРегистра(Регистр, Знач Ресурс, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не Регистр.Метаданные().Ресурсы.Найти(Ресурс) = Неопределено) Тогда
		Ресурс = Регистр.Метаданные().Ресурсы.Найти(Ресурс).Синоним;
	ИначеЕсли (Не Регистр.Метаданные().Реквизиты.Найти(Ресурс) = Неопределено) Тогда
		Ресурс = Регистр.Метаданные().Реквизиты.Найти(Ресурс).Синоним;
	КонецЕсли;
	
	ТекстСообщения = "Перед записью данных регистра «" + Регистр.Метаданные().Синоним + "» необходимо заполнить реквизит «" + Ресурс + "».";
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры

Процедура СообщитьОбНезаполненомРеквизитеРегистра(Регистр, Знач Реквизит, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если (Не Регистр.Метаданные().Реквизиты.Найти(Реквизит) = Неопределено) Тогда
		Реквизит = Регистр.Метаданные().Реквизиты.Найти(Реквизит).Синоним;
	КонецЕсли;
	
	ТекстСообщения = "Перед записью данных регистра «" + Регистр.Метаданные().Синоним + "» необходимо заполнить реквизит «" + Реквизит + "».";
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);

КонецПроцедуры




// Процедура проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект, ДокументОбъект. Объект проводимого документа;
//  СтруктураОбязательныхПолей, Структура. Структура содержащая имена полей, которые собственно и надо проверить;
//  Отказ, Булево. Флаг отказа в проведении;
//  Заголовок, Строка. Заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	Для Каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		Если ОбщегоНазначения.ЗначениеНЕЗаполнено(Значение) Тогда

			Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				СообщитьОбНезаполненомРеквизитеДокумента(ДокументОбъект, КлючЗначение.Ключ, Отказ, Заголовок);
			Иначе
				СообщитьОбНезаполненомРеквизитеДокумента(ДокументОбъект, КлючЗначение.Значение, Отказ, Заголовок);
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект, ДокументОбъект. Ообъект проводимого документа;
//  ИмяТабличнойЧасти, Строка. Ттабличная часть документа;
//  СтруктураОбязательныхПолей, Структура. Структура, содержащая имена полей, которые собственно и надо проверить;
//  Отказ, Булево. Флаг отказа в проведении;
//  Заголовок, Строка. Заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт

	ТабличнаяЧасть = ДокументОбъект[ИмяТабличнойЧасти];

	// Цмкл по строкам табличной части.
	Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		// Цмкл по проверяемым полям.
		Для Каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если ОбщегоНазначения.ЗначениеНЕЗаполнено(Значение) Тогда

				Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
					СообщитьОбНезаполненомРеквизитеТабличнойЧастиДокумента(ДокументОбъект, ИмяТабличнойЧасти, КлючЗначение.Ключ, СтрокаТаблицы.НомерСтроки, Отказ, Заголовок);
				Иначе
					СообщитьОбНезаполненомРеквизитеТабличнойЧастиДокумента(ДокументОбъект, ИмяТабличнойЧасти, КлючЗначение.Значение, СтрокаТаблицы.НомерСтроки, Отказ, Заголовок);
				КонецЕсли;

			КонецЕсли;

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()



Функция СтрЗаменитьИгнорируяРегистр(Знач ИсходнаяСтрока, ПодстрокаПоиска, ПодстрокаЗамены) Экспорт
	
	НИсходнаяСтрока = НРег(ИсходнаяСтрока);
	НПодстрокаПоиска = НРег(ПодстрокаПоиска);
	ДлиннаПодстрокаПоиска = СтрДлина(ПодстрокаПоиска);
	
	Позиция = Найти(НИсходнаяСтрока, НПодстрокаПоиска);
	Пока (Не Позиция = 0) Цикл
		ИсходнаяСтрока = Лев(ИсходнаяСтрока, Позиция-1) + ПодстрокаЗамены + Сред(ИсходнаяСтрока, Позиция+ДлиннаПодстрокаПоиска);
		НИсходнаяСтрока = Лев(НИсходнаяСтрока, Позиция-1) + ПодстрокаЗамены + Сред(НИсходнаяСтрока, Позиция+ДлиннаПодстрокаПоиска);
		
		Позиция = Найти(НИсходнаяСтрока, НПодстрокаПоиска);
	КонецЦикла;
	
	Возврат ИсходнаяСтрока;
	
КонецФункции


Функция СократитьСтроку(знач Значение, Длинна) Экспорт
	// нормализация
	Значение = СокрП(Значение);
	
	// резултат
	Если (СтрДлина(Значение) > Длинна) Тогда
		Возврат СокрП(Лев(Значение, Длинна-3)) + "...";
	Иначе
		Возврат Значение;
	КонецЕсли;
КонецФункции



#Если Клиент Тогда

Функция ВыбратьСправочникИзСписка(ТипЗначения, ЭтаФорма, ЭлементФормы, НачальноеЗначение = Неопределено, ВыборГруппИЭлементов = Неопределено, ПлоскимСписком = Ложь, СтруктураОтбора = Неопределено) Экспорт

	// Тип значения строкой.
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);
	Если Не Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Выборка данных запросом.
	Запрос = Новый Запрос;
	
	Если (ОбъектМетаданных.Иерархический) Тогда
		
		Если (ОбъектМетаданных.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияЭлементов) Тогда
			Запрос.Текст = "ВЫБРАТЬ ЛОЖЬ КАК ЭтоГруппа, Справочник.Ссылка, Справочник.Наименование, Справочник.Родитель ИЗ Справочник." + ОбъектМетаданных.Имя + " КАК Справочник ГДЕ (НЕ Справочник.ПометкаУдаления) ";
		Иначе
			Запрос.Текст = "ВЫБРАТЬ Справочник.ЭтоГруппа, Справочник.Ссылка, Справочник.Наименование, Справочник.Родитель ИЗ Справочник." + ОбъектМетаданных.Имя + " КАК Справочник ГДЕ (НЕ Справочник.ПометкаУдаления) ";
		КонецЕсли;
		Если (ОбъектМетаданных.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
			Если (ВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.Группы) Тогда
				Запрос.Текст = Запрос.Текст + "И Справочник.ЭтоГруппа ";
			ИначеЕсли (Не ВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.ГруппыИЭлементы) Тогда
				Запрос.Текст = Запрос.Текст + "И (НЕ Справочник.ЭтоГруппа) ";
			КонецЕсли;
		КонецЕсли;
		Если (Не СтруктураОтбора = Неопределено) Тогда
			НаложитьСтруктуруОтбора(Запрос, СтруктураОтбора, "Справочник");
		КонецЕсли;
		Если ПлоскимСписком Тогда
			Запрос.Текст = Запрос.Текст + " УПОРЯДОЧИТЬ ПО Наименование";
		Иначе
			Запрос.Текст = Запрос.Текст + " УПОРЯДОЧИТЬ ПО Родитель ИЕРАРХИЯ, ЭтоГруппа УБЫВ, Наименование";
		КонецЕсли;
		
	Иначе
		Запрос.Текст = "ВЫБРАТЬ Справочник.Ссылка, Справочник.Наименование ИЗ Справочник." + ОбъектМетаданных.Имя + " КАК Справочник ГДЕ (НЕ Справочник.ПометкаУдаления) ";
		Если (Не СтруктураОтбора = Неопределено) Тогда
			НаложитьСтруктуруОтбора(Запрос, СтруктураОтбора, "Справочник");
		КонецЕсли;
		Запрос.Текст = Запрос.Текст + " УПОРЯДОЧИТЬ ПО Наименование";
	КонецЕсли;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	
	// Формирование списка.
	СписокЗначений = Новый СписокЗначений;
	Выборка = РезультатЗапроса.Выбрать();
	Если (Не ОбъектМетаданных.Иерархический) Тогда
		
		Пока Выборка.Следующий() Цикл
			СписокЗначений.Добавить(Выборка.Ссылка, Выборка.Наименование, , БиблиотекаКартинок.ЭлементСправочника);
		КонецЦикла;
		
	ИначеЕсли ПлоскимСписком Тогда
		
		Пока Выборка.Следующий() Цикл
			Если Выборка.ЭтоГруппа Тогда
				СписокЗначений.Добавить(Выборка.Ссылка, Выборка.Наименование, , БиблиотекаКартинок.ГруппаСправочника);
			Иначе
				СписокЗначений.Добавить(Выборка.Ссылка, Выборка.Наименование, , БиблиотекаКартинок.ЭлементСправочника);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Пока Выборка.Следующий() Цикл
			
			Если ЗначениеЗаполнено(Выборка.Родитель) Тогда
				Наименование = СтрЗаменить(Выборка.Родитель.ПолноеНаименование(),"/"," › ") + " » " + Выборка.Наименование;
			Иначе
				Наименование = Выборка.Наименование;
			КонецЕсли;
			Если Выборка.ЭтоГруппа Тогда
				СписокЗначений.Добавить(Выборка.Ссылка, Наименование, , БиблиотекаКартинок.ГруппаСправочника);
			Иначе
				СписокЗначений.Добавить(Выборка.Ссылка, Наименование, , БиблиотекаКартинок.ЭлементСправочника);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Выбор значения.
	ЭлементСпискаЗначений = ЭтаФорма.ВыбратьИзСписка(СписокЗначений, ЭлементФормы, СписокЗначений.НайтиПоЗначению(НачальноеЗначение));
	
	Если (ЭлементСпискаЗначений = Неопределено) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЭлементСпискаЗначений.Значение;

КонецФункции

 #КонецЕсли


// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции


// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Значение - Null, Булево, Строка
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//
Функция ПреобразоватьВЧисло(Значение) Экспорт
	
	Если (Значение = Null) Или (Значение = Неопределено) Тогда
		
		Возврат 0;
		
	Иначе
		Если (ТипЗнч(Значение) = Тип("Строка")) Тогда
			
			Первый = Неопределено; Длина = Неопределено; Разделитель = Ложь;
			
			Для Поз = 1 По СтрДлина(Значение) Цикл
				КодСимвола = КодСимвола(Сред(Значение, Поз, 1));
				
				Если (Первый = Неопределено) Тогда
					Если (КодСимвола >= 48) И (КодСимвола <= 57) Тогда
						Первый = Поз; Длина = 1;
					КонецЕсли;
				Иначе
					Если (КодСимвола = 44) Или (КодСимвола = 46) Тогда
						Если Разделитель Тогда
							Прервать;
						КонецЕсли;
						Длина = Длина + 1; Разделитель = Истина;
					ИначеЕсли (КодСимвола >= 48) И (КодСимвола <= 57) Тогда
						Длина = Длина + 1;
					Иначе
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			Если (Первый = Неопределено) Тогда
				Возврат 0;
			Иначе
				Возврат Число(Сред(Значение, Первый, Длина))
			КонецЕсли;
		
		Иначе
	
			Попытка
				Возврат Число(Значение)
			Исключение
				Возврат 0;
			КонецПопытки;
		
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ПреобразоватьВЧисло()


// Функция возвращает текстовую строку, сформированную на основании спец. шаблона,
// подставляя значения переданных параметров.	
// 
// Параметры
//  СтрокаШаблон – Строка – Строка шаблон, в тексте которой
//                 есть указания на то, куда вставить представления 
//                 параметров. 
//                 Параметры отмечаются текстом ¤1¤...¤20¤.
//                 Символ "¤" можно набрать при помощи Alt+0164
//  Пар1...Пар20 – произвольного типа – параметры,
//                 строковое представление которых будет 
//                 подставлятся в шаблон.
//
// Возвращаемое значение:
//   Строка   – сформированная текстовая строка
//
Функция СтрокаШаблон(Знач СтрокаШаблон, 
										Знач Пар1  = "", Знач Пар2  = "",
										Знач Пар3  = "", Знач Пар4  = "", Знач Пар5  = "",
										Знач Пар6  = "", Знач Пар7  = "", Знач Пар8  = "",
										Знач Пар9  = "", Знач Пар10 = "", Знач Пар11 = "",
										Знач Пар12 = "", Знач Пар13 = "", Знач Пар14 = "",
										Знач Пар15 = "", Знач Пар16 = "", Знач Пар17 = "",
										Знач Пар18 = "", Знач Пар19 = "", Знач Пар20 = "") Экспорт
										
	ПризнакПараметра = "¤";
	МетаСимвол       = "\¤"; //заменяется на признак параметра
	
	Для Счетчик = 1 По 20 Цикл
			
		ПерваяПозицияВхожденияПараметра = Найти(СтрокаШаблон, ""+ ПризнакПараметра + Счетчик + ПризнакПараметра);
				
		Если ПерваяПозицияВхожденияПараметра = 0 Тогда
			// этот параметр не используется
			Продолжить;	
		КонецЕсли; 
				
		ПараметрВСтроку = "";
		Выполнить("ПараметрВСтроку = Строка(Пар" + Счетчик + ")");
				
		СтрокаШаблон = СтрЗаменить(СтрокаШаблон, ПризнакПараметра + Счетчик + ПризнакПараметра, ПараметрВСтроку);
				
	КонецЦикла;									
		
	ПозицияМетаСимвола = СтрЗаменить(СтрокаШаблон, МетаСимвол,ПризнакПараметра);

	Возврат СтрокаШаблон;
	
КонецФункции //СтрШаблон()



// Увеличивает номер в переданной строке на 1
//
// Параметры
//  ПоследнийНомер - строка - представляет собой номер (документа, табельный и т.п.)
//
// Возвращаемое значение:
//  строка  - следующий по порядку номер
//
Функция ПолучитьСледующийНомер(ПоследнийНомер) Экспорт 

	ДлинаНомера = СтрДлина(ПоследнийНомер);
	Если Не Булево(ДлинаНомера) Тогда
		Возврат "1"
	КонецЕсли;
	СчетчикСимв = ДлинаНомера;
	Пока Булево(СчетчикСимв) Цикл
		Если ОбщегоНазначения.ТолькоЦифрыВСтроке(Сред(ПоследнийНомер, СчетчикСимв, 1)) Тогда
			СчетчикСимв = СчетчикСимв - 1;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если (СчетчикСимв = ДлинаНомера) Тогда
		НомерЧисловой = 1;
	Иначе
		НомерЧисловой = Число(Сред(ПоследнийНомер, СчетчикСимв + 1));
	КонецЕсли;
	Если (НомерЧисловой < Pow(10, ДлинаНомера - СчетчикСимв) - 1) Тогда
		СледующийНомер = НомерЧисловой + 1;
	Иначе
		СледующийНомер = НомерЧисловой;
	КонецЕсли;
	НовыйНомер = Лев(ПоследнийНомер,  СчетчикСимв) + Формат(СледующийНомер,"ЧЦ=" + (ДлинаНомера - СчетчикСимв) + "; ЧВН=; ЧГ=0");
	Возврат НовыйНомер
	
КонецФункции // ПолучитьСледующийНомер()



Функция ЗаменитьСимволы(Значение, ЗаменяемыеСимволы, СимволыПодмены) Экспорт
	
	// Подмена символов.
	Длинна = СтрДлина(СокрП(Значение)); Результат = "";
	Для Каждый = 1 По Длинна Цикл
		Символ = Сред(Значение, Каждый, 1);
		
		Позиция = Найти(Символ, ЗаменяемыеСимволы);
		Если (Позиция = 0) Тогда
			Результат = Результат + Символ;
		Иначе
			Результат = Результат + Сред(СимволыПодмены, Позиция, 1);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции




// Позволяет определить есть ли среди реквизитов справочника реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита, Строка. Строковое имя искомого реквизита, 
//  МетаданныеСправочника, Метаданные. Метаданные справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево. Истина, реквизит с таким именем существует.
//
Функция ЕстьРеквизитСправочника(ИмяРеквизита, МетаданныеСправочника) Экспорт

	Возврат (Не МетаданныеСправочника.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитСправочника()

// Позволяет определить есть ли среди реквизитов шапки документа реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита, Строка. Строковое имя искомого реквизита, 
//  МетаданныеДокумента, Метаданные. Метаданные документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево. Истина, реквизит с таким именем существует.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат (Не МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли у документа табличная часть с переданным именем.
//
// Параметры: 
//  ИмяРеквизита, Строка. Строковое имя искомого реквизита, 
//  МетаданныеСправочника, Метаданные. Метаданные справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево. Истина, реквизит с таким именем существует.
//
Функция ЕстьТабличнаяЧастьДокумента(ИмяТабличнойЧасти, МетаданныеДокумента) Экспорт

	Возврат (Не МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабличнойЧасти) = Неопределено);

КонецФункции // ЕстьТабличнаяЧастьДокумента()

Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабличнойЧасти) Экспорт

	Возврат ЕстьРеквизитТабличнойЧастьДокумента(ИмяТабличнойЧасти, ИмяРеквизита, МетаданныеДокумента);

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

Функция ЕстьРеквизитТабличнойЧастьДокумента(ИмяТабличнойЧасти, ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат ЕстьТабличнаяЧастьДокумента(ИмяТабличнойЧасти, МетаданныеДокумента) И (Не МетаданныеДокумента.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитТабличнойЧастьДокумента()



// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекущийПользователь = Неопределено, СтруктураИсключаемых = Неопределено) Экспорт

	Если (ТекущийПользователь = Неопределено) Тогда
		ТекущийПользователь = глЗначениеПеременной("глТекущийПользователь");
	КонецЕсли;	
	
	Если (СтруктураИсключаемых = Неопределено) Тогда
		СтруктураИсключаемых = Новый Структура;
	КонецЕсли;	
	
	// Метаданные.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	// Модуль.
	Если ЕстьРеквизитДокумента("Модуль", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Модуль)) Тогда
		ДокументОбъект.Модуль = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь, "ОсновнойМодуль");
		Если (Не ЗначениеЗаполнено(ДокументОбъект.Модуль))и(НЕ(СтруктураИсключаемых.Свойство("Модуль"))) Тогда
			ДокументОбъект.Модуль = Перечисления.МодулиИПодсистемы.Доставка; // TODO: Изменить на ресторан.
		КонецЕсли;
	КонецЕсли;
	
	
	// Ответственный.
	Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Ответственный)) Тогда
		ДокументОбъект.Ответственный = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь, "ОсновнойОтветственный");
		Если Не ЗначениеЗаполнено(ДокументОбъект.Ответственный) Тогда
			ДокументОбъект.Ответственный = ТекущийПользователь;
		КонецЕсли;
	КонецЕсли;

	// Сотрудник.
	Если ЕстьРеквизитДокумента("Сотрудник", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Сотрудник)) И (Не СтруктураИсключаемых.Свойство("Сотрудник")) Тогда
		ДокументОбъект.Сотрудник = УправлениеПользователями.ОпределитьСотрудникаПоПользователю(ТекущийПользователь);
	КонецЕсли;
	
	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	// Оплата.

	// Флаги принадлежности к учету.
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) И (Не СтруктураИсключаемых.Свойство("ОтражатьВУправленческомУчете")) Тогда
		ДокументОбъект.ОтражатьВУправленческомУчете = Истина;
	КонецЕсли;
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) И (Не СтруктураИсключаемых.Свойство("ОтражатьВБухгалтерскомУчете")) Тогда
		ДокументОбъект.ОтражатьВБухгалтерскомУчете = Истина;
	КонецЕсли;
	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) И (Не СтруктураИсключаемых.Свойство("ОтражатьВНалоговомУчете")) Тогда
		ДокументОбъект.ОтражатьВНалоговомУчете = Ложь;
	КонецЕсли;
	
	// Ресторан.
	Если ЕстьРеквизитДокумента("Ресторан", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Ресторан)) Тогда
		ДокументОбъект.Ресторан = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь, "ОсновнойРесторан");
	КонецЕсли;
	
	//Если ЕстьРеквизитДокумента("ДатаНачалаПериода", МетаданныеДокумента) И ЗначениеНеЗаполнено(ДокументОбъект.ДатаНачалаПериода) Тогда
	//	ДокументОбъект.ДатаНачалаПериода = ТекущаяДата();
	//КонецЕсли;
	
	Если ЗначениеНеЗаполнено(ДокументОбъект.Дата) Тогда
		ДокументОбъект.Дата = ТекущаяДата();
	КонецЕсли;
	
	// Состояние.
	//Если ЗначениеЗаполнено(ДокументОбъект.Дата) Тогда
	//	ДатаСостояния = ДокументОбъект.Дата;
	//Иначе
	//	ДатаСостояния = ТекущаяДата();
	//КонецЕсли;
	//Если ЕстьРеквизитДокумента("Состояние", МетаданныеДокумента) И (Не ЗначениеЗаполнено(ДокументОбъект.Состояние)) Тогда
	//	Если (Состояние = Неопределено) Тогда
	//		Состояние = Перечисления.СостояниеДокумента.Открыт;
	//	КонецЕсли;
	//	Если (Состояние = Перечисления.СостояниеДокумента.Закрыт) Тогда
	//		ДокументОбъект.ДатаЗакрытия = ДатаСостояния;
	//		ДокументОбъект.ДатаОткрытия = ДатаСостояния;
	//		ДокументОбъект.ДатаСоздания = ДатаСостояния;
	//	ИначеЕсли (Состояние = Перечисления.СостояниеДокумента.Открыт) Тогда
	//		ДокументОбъект.ДатаОткрытия = ДатаСостояния;
	//		ДокументОбъект.ДатаСоздания = ДатаСостояния;
	//	Иначе
	//		ДокументОбъект.ДатаСоздания = ДатаСостояния;
	//	КонецЕсли;
	//	ДокументОбъект.Состояние = Состояние;
	//КонецЕсли;
	
	// Ресторан.
	//Если ЕстьРеквизитДокумента("ДатаНачалаПериода", МетаданныеДокумента) И ЗначениеНЕЗаполнено(ДокументОбъект.ДатаНачалаПериода) Тогда
	//	ДокументОбъект.ДатаНачалаПериода = ДатаСостояния;
	//КонецЕсли;
	
КонецПроцедуры // ЗаполнитьШапкуДокумента()

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование, СтруктураИсключаемых = Неопределено) Экспорт

	// Исключаемые.
	Если (СтруктураИсключаемых = Неопределено) Тогда
		СтруктураИсключаемых = Новый Структура;
	КонецЕсли;
	
		//ДисконтнаяКарта = Основание.ДисконтнаяКарта;
		//КатегорияДокумента = Основание.КатегорияДокумента;
		//КатегорияКонтрагента = Основание.КатегорияКонтрагента;
		//КоличествоКлиентов = Основание.КоличествоКлиентов;
		//Комментарий = Основание.Комментарий;
		//Контрагент = Основание.Контрагент;
		//Модуль = Основание.Модуль;
		//Оплата = Основание.Оплата;
		//Ответственный = Основание.Ответственный;
		//ОтражатьВБухгалтерскомУчете = Основание.ОтражатьВБухгалтерскомУчете;
		//ОтражатьВНалоговомУчете = Основание.ОтражатьВНалоговомУчете;
		//ОтражатьВУправленческомУчете = Основание.ОтражатьВУправленческомУчете;
		//ПродолжительностьДоставки = Основание.ПродолжительностьДоставки;
		//ПродолжительностьПроизводства = Основание.ПродолжительностьПроизводства;
		//Ресторан = Основание.Ресторан;
		//Сотрудник = Основание.Сотрудник;
		//Сделка = Основание.Ссылка;
		//Стол = Основание.Стол;
		//ТребуемаяДатаНачалаПериода = Основание.ТребуемаяДатаНачалаПериода;
		//ТребуемаяДатаОкончанияПериода = Основание.ТребуемаяДатаОкончанияПериода;
		
	
	
	
	// Шапка по умолчанию.
	ЗаполнитьШапкуДокумента(ДокументОбъект, глЗначениеПеременной("глТекущийПользователь"));
	
	// Типы документов.
	МетаданныеДокумента = ДокументОбъект.Метаданные(); МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// ДокументОснование.
	Если ЕстьРеквизитДокумента("ДокументОснование", МетаданныеДокумента) Тогда
		ДокументОбъект.ДокументОснование = ДокументОснование.Ссылка;
	КонецЕсли;
	
	// Сотрудник.
	Если ЕстьРеквизитДокумента("Сотрудник", МетаданныеДокумента) Тогда
		ДокументОбъект.Сотрудник = УправлениеПользователями.ОпределитьСотрудникаПоПользователю(глЗначениеПеременной("глТекущийПользователь"));
	КонецЕсли;
	
	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) И ЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	// Оплата.
	Если ЕстьРеквизитДокумента("Оплата", МетаданныеДокумента) И ЕстьРеквизитДокумента("Оплата", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Оплата = ДокументОснование.Оплата;
	КонецЕсли;

	// Флаги принадлежности к учету.
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВУправленческомУчете = ДокументОснование.ОтражатьВУправленческомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокумента) И ЗначениеЗаполнено(ДокументОбъект.Оплата) Тогда	
			ДокументОбъект.ОтражатьВУправленческомУчете = ДокументОбъект.Оплата.ОтражатьВУправленческомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокументаОснования) И ЗначениеЗаполнено(ДокументОснование.Оплата) Тогда	
			ДокументОбъект.ОтражатьВУправленческомУчете = ДокументОснование.Оплата.ОтражатьВУправленческомУчете;
		Иначе
			ДокументОбъект.ОтражатьВУправленческомУчете = Истина;
		КонецЕсли;
	КонецЕсли;
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОснование.ОтражатьВБухгалтерскомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокумента) И ЗначениеЗаполнено(ДокументОбъект.Оплата) Тогда	
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОбъект.Оплата.ОтражатьВБухгалтерскомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокументаОснования) И ЗначениеЗаполнено(ДокументОснование.Оплата) Тогда	
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОснование.Оплата.ОтражатьВБухгалтерскомУчете;
		Иначе
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = Истина;
		КонецЕсли;
	КонецЕсли;
	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОснование.ОтражатьВНалоговомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокумента) И ЗначениеЗаполнено(ДокументОбъект.Оплата) Тогда	
			ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОбъект.Оплата.ОтражатьВНалоговомУчете;
		ИначеЕсли ЕстьРеквизитДокумента("Оплата", МетаданныеДокументаОснования) И ЗначениеЗаполнено(ДокументОснование.Оплата) Тогда	
			ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОснование.Оплата.ОтражатьВНалоговомУчете;
		Иначе
			ДокументОбъект.ОтражатьВНалоговомУчете = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	// Ресторан.
	Если ЕстьРеквизитДокумента("Ресторан", МетаданныеДокумента) И ЕстьРеквизитДокумента("Ресторан", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Ресторан = ДокументОснование.Ресторан;
	КонецЕсли;
	
	// ДатаНачалаПериода.
	Если ЕстьРеквизитДокумента("ДатаНачалаПериода", МетаданныеДокумента) И ЕстьРеквизитДокумента("ДатаНачалаПериода", МетаданныеДокументаОснования) Тогда
		//ДокументОбъект.ДатаНачалаПериода = ДокументОснование.ДатаНачалаПериода;
	КонецЕсли;
	
	// ДатаОкончанияПериода.
	Если ЕстьРеквизитДокумента("ДатаОкончанияПериода", МетаданныеДокумента) И ЕстьРеквизитДокумента("ДатаОкончанияПериода", МетаданныеДокументаОснования) Тогда
		//ДокументОбъект.ДатаОкончанияПериода = ДокументОснование.ДатаОкончанияПериода;
	КонецЕсли;
	
	////Костенюк Александр-Закомментировано 14.08.2013
	//// при переносе скидки переноситься не должны
	//// Дисконтная карта.
	//Если ЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокумента) И ЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокументаОснования) Тогда
	//	ДокументОбъект.ДисконтнаяКарта = ДокументОснование.ДисконтнаяКарта;
	//КонецЕсли;
	
	// Касса ККМ.
	Если ЕстьРеквизитДокумента("КассаККМ", МетаданныеДокумента) И ЕстьРеквизитДокумента("КассаККМ", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.КассаККМ = ДокументОснование.КассаККМ;
	КонецЕсли;
	
	//Костенюк Александр-Старт 14.08.2013
	// КатегорияКонтрагента.
	Если ЕстьРеквизитДокумента("КатегорияКонтрагента", МетаданныеДокумента) И ЕстьРеквизитДокумента("КатегорияКонтрагента", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.КатегорияКонтрагента = ДокументОснование.КатегорияКонтрагента;
	КонецЕсли;
	//Костенюк Александр-Финиш 14.08.2013
	
	//Костенюк Александр-Старт 26.08.2014
	// КатегорияДокумента.
	Если ЕстьРеквизитДокумента("КатегорияДокумента", МетаданныеДокумента) И ЕстьРеквизитДокумента("КатегорияДокумента", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.КатегорияДокумента = ДокументОснование.КатегорияДокумента;
	КонецЕсли;
	//Костенюк Александр-Финиш 26.08.2014

	ОбщегоНазначения.ЗаполнитьШапкуДокумента(ДокументОбъект, глЗначениеПеременной("глТекущийПользователь"), Новый Структура("ОтражатьВУправленческомУчете,ОтражатьВБухгалтерскомУчете,ОтражатьВНалоговомУчете"));
	
КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()





Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если (Кэш = Неопределено) Тогда
		// Кэш не был проинициализирован.
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре.
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД.
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
		НеКешировать = Истина;
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глТекущаяГруппаПользователей") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущаяГруппаПользователей;
		НеКешировать = Истина;
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глТекущийРежимРаботы") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийРежимРаботы;
		НеКешировать = Истина;

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаРегламентированногоУчета") Тогда
		НайденноеЗначение = Константы.ВалютаРегламентированногоУчета.Получить();
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВестиУчетСебестоимости") Тогда
		НайденноеЗначение = Константы.ВестиУчетСебестоимости.Получить();
			
	Иначе
		
		Попытка
			ЗначениеИзПараметраСеанса = ПараметрыСеанса[Сред(ИмяПараметра, 3)];
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		Если ТипЗнч(ЗначениеИзПараметраСеанса) = Тип("ХранилищеЗначения") Тогда
			 Возврат ЗначениеИзПараметраСеанса.Получить();
		Иначе
			 Возврат ЗначениеИзПараметраСеанса;
		КонецЕсли; 
		
	КонецЕсли;
	
	Если (Не НеКешировать = Истина) Тогда
		Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
		КэшИзменен = Истина;
	КонецЕсли;          	
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если (Кэш = Неопределено) Тогда
		// Кэш не был проинициализирован.
		Кэш = Новый Структура;
	КонецЕсли;		
	
	//Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	//КонецЕсли;
	
	#Если Клиент Или ВнешнееСоединение Тогда
		
		Если ОбновлятьВоВсехКэшах Тогда
			
		Кэш = ПараметрыСеанса.ОбщиеЗначения.Получить();
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
		ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(Кэш, Новый СжатиеДанных(0));
	КонецЕсли;
	
	#КонецЕсли
	
КонецПроцедуры


// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()  


Функция ПолучитьСтруктуруОтбора(Отбор) Экспорт
	
	СтруктураОтбора = Новый Структура;	
	
	// Получение отбора.
	Для Каждого ЭлементаОтбора Из Отбор Цикл
		Если Не ЭлементаОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		// -- Получение отбора.
		ИмяЭлементаОтбора = ЭлементаОтбора.Имя;
		
		Если (ЭлементаОтбора.ВидСравнения = ВидСравнения.Больше) Тогда
			ИмяЭлементаОтбора = "БОЛЬШЕ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно) Тогда
			ИмяЭлементаОтбора = "БОЛЬШЕИЛИРАВНО_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ВИерархии) Тогда
			ИмяЭлементаОтбора = "ВИЕРАРХИИ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ВСписке) Тогда
			ИмяЭлементаОтбора = "ВСПИСКЕ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии) Тогда
			ИмяЭлементаОтбора = "ВСПИСКЕПОИЕРАРХИИ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.Интервал) Тогда
			ИмяЭлементаОтбора = "ИНТЕРВАЛ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы) Тогда
			ИмяЭлементаОтбора = "ИНТЕРВАЛВКЛЮЧАЯГРАНИЦЫ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало) Тогда
			ИмяЭлементаОтбора = "ИНТЕРВАЛВКЛЮЧАЯНАЧАЛО_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание) Тогда
			ИмяЭлементаОтбора = "ИНТЕРВАЛВКЛЮЧАЯОКОНЧАНИЕ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.Меньше) Тогда
			ИмяЭлементаОтбора = "МЕНЬШЕ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно) Тогда
			ИмяЭлементаОтбора = "МЕНЬШЕИЛИРАВНО_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.НеВИерархии) Тогда
			ИмяЭлементаОтбора = "НЕВИЕРАРХИИ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.НеВСписке) Тогда
			ИмяЭлементаОтбора = "НЕВСПИСКЕ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии) Тогда
			ИмяЭлементаОтбора = "НЕВСПИСКЕПОИЕРАРХИИ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.НеРавно) Тогда
			ИмяЭлементаОтбора = "НЕРАВНО_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.НеСодержит) Тогда
			ИмяЭлементаОтбора = "НЕСОДЕРЖИТ_" + ИмяЭлементаОтбора;
		ИначеЕсли (ЭлементаОтбора.ВидСравнения = ВидСравнения.Содержит) Тогда
			ИмяЭлементаОтбора = "СОДЕРЖИТ_" + ИмяЭлементаОтбора;
		КонецЕсли;

		Если (ЭлементаОтбора.ВидСравнения = ВидСравнения.Интервал) Или (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы) Или (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало) Или (ЭлементаОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание) Тогда
			ЗначениеОтбора = Новый Структура("ЗначениеС,ЗначениеПо", ЭлементаОтбора.ЗначениеС, ЭлементаОтбора.ЗначениеПо);
		Иначе
			ЗначениеОтбора = ЭлементаОтбора.Значение;
		КонецЕсли;
		
		СтруктураОтбора.Вставить(ИмяЭлементаОтбора, ЗначениеОтбора);
	КонецЦикла;
	
	Возврат СтруктураОтбора;
	
КонецФункции

Процедура НаложитьСтруктуруОтбора(Отбор, СтруктураОтбора, Префикс = "") Экспорт
	
	// Нормализация.
	Если (Не ТипЗнч(СтруктураОтбора) = Тип("Структура")) Тогда
		Возврат;
	КонецЕсли;
	
	// Работа с запросом.
	РаботаСЗапросом = (ТипЗнч(Отбор) = Тип("Запрос"));
	
	// Наложение отбора.
	ПервоеУсловие = Истина;
	Для Каждого ЭлементСтруктуры Из СтруктураОтбора Цикл
		// -- Параметры отбора.
		Позиция = Найти(ЭлементСтруктуры.Ключ, "_");
		Если (Позиция = 0) Тогда
			ИмяЭлементаОтбора = ЭлементСтруктуры.Ключ;
			ВидСравненияОтбора = ВидСравнения.Равно;
		Иначе
			ИмяЭлементаОтбора = Сред(ЭлементСтруктуры.Ключ, Позиция + 1);
			ИмяВидаСравнения = Лев(ЭлементСтруктуры.Ключ, Позиция - 1);
			
			Если (ИмяВидаСравнения = "БОЛЬШЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.Больше;
			ИначеЕсли (ИмяВидаСравнения = "БОЛЬШЕИЛИРАВНО") Или (ИмяВидаСравнения = "БОЛЬШЕРАВНО") Тогда
				ВидСравненияОтбора = ВидСравнения.БольшеИлиРавно;
			ИначеЕсли (ИмяВидаСравнения = "ВИЕРАРХИИ") Тогда
				ВидСравненияОтбора = ВидСравнения.ВИерархии;
			ИначеЕсли (ИмяВидаСравнения = "ВСПИСКЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.ВСписке;
			ИначеЕсли (ИмяВидаСравнения = "ВСПИСКЕПОИЕРАРХИИ") Тогда
				ВидСравненияОтбора = ВидСравнения.ВСпискеПоИерархии;
			ИначеЕсли (ИмяВидаСравнения = "ИНТЕРВАЛ") Тогда
				ВидСравненияОтбора = ВидСравнения.Интервал;
			ИначеЕсли (ИмяВидаСравнения = "ИНТЕРВАЛВКЛЮЧАЯГРАНИЦЫ") Или (ИмяВидаСравнения = "ИНТЕРВАЛГРАНИЦЫ") Или (ИмяВидаСравнения = "ГРАНИЦЫ") Тогда
				ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяГраницы;
			ИначеЕсли (ИмяВидаСравнения = "ИНТЕРВАЛВКЛЮЧАЯНАЧАЛО") Или (ИмяВидаСравнения = "ИНТЕРВАЛНАЧАЛО") Или (ИмяВидаСравнения = "НАЧАЛО") Тогда
				ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяНачало;
			ИначеЕсли (ИмяВидаСравнения = "ИНТЕРВАЛВКЛЮЧАЯОКОНЧАНИЕ") Или (ИмяВидаСравнения = "ИНТЕРВАЛОКОНЧАНИЕ") Или (ИмяВидаСравнения = "ОКОНЧАНИЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяОкончание;
			ИначеЕсли (ИмяВидаСравнения = "МЕНЬШЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.Меньше;
			ИначеЕсли (ИмяВидаСравнения = "МЕНЬШЕИЛИРАВНО") Или (ИмяВидаСравнения = "МЕНЬШЕРАВНО") Тогда
				ВидСравненияОтбора = ВидСравнения.МеньшеИлиРавно;
			ИначеЕсли (ИмяВидаСравнения = "НЕВИЕРАРХИИ") Тогда
				ВидСравненияОтбора = ВидСравнения.НеВИерархии;
			ИначеЕсли (ИмяВидаСравнения = "НЕВСПИСКЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.НеВСписке;
			ИначеЕсли (ИмяВидаСравнения = "НЕВСПИСКЕПОИЕРАРХИИ") Тогда
				ВидСравненияОтбора = ВидСравнения.НеВСпискеПоИерархии;
			ИначеЕсли (ИмяВидаСравнения = "НЕРАВНО") Или (ИмяВидаСравнения = "НЕ") Тогда
				ВидСравненияОтбора = ВидСравнения.НеРавно;
			ИначеЕсли (ИмяВидаСравнения = "НЕСОДЕРЖИТ") Тогда
				ВидСравненияОтбора = ВидСравнения.НеСодержит;
			ИначеЕсли (ИмяВидаСравнения = "РАВНО") Тогда
				ВидСравненияОтбора = ВидСравнения.Равно;
			ИначеЕсли (ИмяВидаСравнения = "СОДЕРЖИТ") Тогда
				ВидСравненияОтбора = ВидСравнения.Содержит;
			Иначе
				ИмяЭлементаОтбора = ЭлементСтруктуры.Ключ;
				ВидСравненияОтбора = ВидСравнения.Равно;
			КонецЕсли;

		КонецЕсли;
		ЗначениеОтбора = ЭлементСтруктуры.Значение;
		
		
		// -- Наложение отбора.
		Если РаботаСЗапросом Тогда
			// -- Запрос.
			
			Если ПервоеУсловие Тогда
				// ---- Анализ текста запроса.
				ТекстЗапроса = Отбор.Текст;
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.ПС, " ");
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Символы.Таб, " ");
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ")", " ");
				ТекстЗапроса = ВРег(СокрП(ТекстЗапроса));
				
				Если (Прав(ТекстЗапроса, 3) = "ГДЕ") Или (Прав(ТекстЗапроса, 2) = " И") Тогда
					Отбор.Текст = Отбор.Текст + Символы.ПС + Символы.Таб;
				Иначе
					Отбор.Текст = Отбор.Текст + Символы.ПС + Символы.Таб + "И ";
				КонецЕсли;
				
				ПервоеУсловие = Ложь;
			Иначе
				Отбор.Текст = Отбор.Текст + Символы.ПС + Символы.Таб + "И ";
			КонецЕсли;
			
			Если (ВидСравненияОтбора = ВидСравнения.Больше) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " > &Отбор_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.БольшеИлиРавно) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " >= &Отбор_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ВИерархии) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " В ИЕРАРХИИ(&Отбор_" + ИмяЭлементаОтбора + ")";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ВСписке) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " В (&Отбор_" + ИмяЭлементаОтбора + ")";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ВСпискеПоИерархии) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " В ИЕРАРХИИ(&Отбор_" + ИмяЭлементаОтбора + ")";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.Интервал) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " > &ОтборС_" + ИмяЭлементаОтбора + " И " + Префикс + "." + ИмяЭлементаОтбора + " < &ОтборПо_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяГраницы) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " >= &ОтборС_" + ИмяЭлементаОтбора + " И " + Префикс + "." + ИмяЭлементаОтбора + " <= &ОтборПо_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяНачало) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " >= &ОтборС_" + ИмяЭлементаОтбора + " И " + Префикс + "." + ИмяЭлементаОтбора + " < &ОтборПо_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяОкончание) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " > &ОтборС_" + ИмяЭлементаОтбора + " И " + Префикс + "." + ИмяЭлементаОтбора + " <= &ОтборПо_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.Меньше) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " < &Отбор_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.МеньшеИлиРавно) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " <= &Отбор_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеВИерархии) Тогда
				Отбор.Текст = Отбор.Текст + "(НЕ " + Префикс + "." + ИмяЭлементаОтбора + " В ИЕРАРХИИ(&Отбор_" + ИмяЭлементаОтбора + "))";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеВСписке) Тогда
				Отбор.Текст = Отбор.Текст + "(НЕ " + Префикс + "." + ИмяЭлементаОтбора + " В (&Отбор_" + ИмяЭлементаОтбора + "))";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеВСпискеПоИерархии) Тогда
				Отбор.Текст = Отбор.Текст + "(НЕ " + Префикс + "." + ИмяЭлементаОтбора + " В ИЕРАРХИИ(&Отбор_" + ИмяЭлементаОтбора + "))";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеРавно) Тогда
				Отбор.Текст = Отбор.Текст + "(НЕ " + Префикс + "." + ИмяЭлементаОтбора + " = &Отбор_" + ИмяЭлементаОтбора + ")";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеСодержит) Тогда
				Отбор.Текст = Отбор.Текст + "(НЕ " + Префикс + "." + ИмяЭлементаОтбора + " ПОДОБНО &Отбор_" + ИмяЭлементаОтбора + " СПЕЦСИМВОЛ ""~"")";
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.Равно) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " = &Отбор_" + ИмяЭлементаОтбора;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.Содержит) Тогда
				Отбор.Текст = Отбор.Текст + Префикс + "." + ИмяЭлементаОтбора + " ПОДОБНО &Отбор_" + ИмяЭлементаОтбора + " СПЕЦСИМВОЛ ""~"")";
			КонецЕсли;
			
			Если (ВидСравненияОтбора = ВидСравнения.Интервал) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяГраницы) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяНачало) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяОкончание) Тогда
				Попытка Отбор.УстановитьПараметр("ОтборС_"  + ИмяЭлементаОтбора, ЗначениеОтбора.С);  Исключение Отбор.УстановитьПараметр("ОтборС_"  + ИмяЭлементаОтбора, ЗначениеОтбора.ЗначениеС);  КонецПопытки;
				Попытка Отбор.УстановитьПараметр("ОтборПо_" + ИмяЭлементаОтбора, ЗначениеОтбора.По); Исключение Отбор.УстановитьПараметр("ОтборПо_" + ИмяЭлементаОтбора, ЗначениеОтбора.ЗначениеПо); КонецПопытки;
			ИначеЕсли (ВидСравненияОтбора = ВидСравнения.НеСодержит) Или (ВидСравненияОтбора = ВидСравнения.Содержит) Тогда
				ЗначениеОтбора = СтрЗаменить(ЗначениеОтбора, "~", "~~");
				ЗначениеОтбора = СтрЗаменить(ЗначениеОтбора, "%", "~%");
				ЗначениеОтбора = СтрЗаменить(ЗначениеОтбора, "_", "~_");
				ЗначениеОтбора = СтрЗаменить(ЗначениеОтбора, "[", "~[");
				ЗначениеОтбора = СтрЗаменить(ЗначениеОтбора, "-", "~-");
				ЗначениеОтбора = "%" + ЗначениеОтбора + "%";
				Отбор.УстановитьПараметр("Отбор_" + ИмяЭлементаОтбора, ЗначениеОтбора);
			Иначе
				Отбор.УстановитьПараметр("Отбор_" + ИмяЭлементаОтбора, ЗначениеОтбора);
			КонецЕсли;
			
		Иначе
			// -- Отбор.
			ЭлементаОтбора = Отбор[ИмяЭлементаОтбора];
			ЭлементаОтбора.Использование = Истина;
			ЭлементаОтбора.ВидСравнения = ВидСравненияОтбора;
			Если (ВидСравненияОтбора = ВидСравнения.Интервал) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяГраницы) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяНачало) Или (ВидСравненияОтбора = ВидСравнения.ИнтервалВключаяОкончание) Тогда
				Попытка ЭлементаОтбора.ЗначениеС  = ЗначениеОтбора.С;  Исключение ЭлементаОтбора.ЗначениеС  = ЗначениеОтбора.ЗначениеС;  КонецПопытки;
				Попытка ЭлементаОтбора.ЗначениеПо = ЗначениеОтбора.По; Исключение ЭлементаОтбора.ЗначениеПо = ЗначениеОтбора.ЗначениеПо; КонецПопытки;
			Иначе
				ЭлементаОтбора.Значение = ЗначениеОтбора;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры





//Функция РассчитатьПродолжительность(ДатаНачалаПериода, ДатаОкончанияПериода, Дней = Неопределено, Часов = Неопределено) Экспорт
Функция РассчитатьПродолжительность(ДатаНачалаПериода, ДатаОкончанияПериода, Дней = Неопределено, Часов = Неопределено, КоличествоЧасовРасчетное = Неопределено) Экспорт //Костенюк Александр 30.06.2016
	
	// Проверка входных параметров.
	Если (ТипЗнч(ДатаНачалаПериода) = Тип("Дата")) И (ЗначениеНЕЗаполнено(ДатаНачалаПериода) Или ЗначениеНЕЗаполнено(ДатаОкончанияПериода) Или (ДатаНачалаПериода > ДатаОкончанияПериода)) Тогда
		Дней = Неопределено;
		Часов = Неопределено;
		Возврат ПустоеЗначениеТипа(Тип("Строка"));
	КонецЕсли;
	
	// Рассчет.
	СекундВДне = 86400; СекундВЧасе = 3600; СекундВМинуте = 60; ЧасовВДне = 24; МинутВЧасе = 60;
	
	Коэффициент = РегистрыСведений.НастройкаПараметровУчета.Получить().УчетРабочегоВремениКоэффициентОкругленияПериода; //Костенюк Александр 30.06.2016
	
	Если (ТипЗнч(ДатаНачалаПериода) = Тип("Дата")) Тогда
		// -- По датам.
		Продолжительность = ДатаОкончанияПериода - ДатаНачалаПериода;
		Дней = Цел(Продолжительность / СекундВДне);
		Часов = Продолжительность / СекундВЧасе - Дней * ЧасовВДне;
		КоличествоЧасовРасчетное = (ОкруглитьПериод(ДатаОкончанияПериода, Минута(ДатаОкончанияПериода) / СекундВМинуте, Коэффициент) - ОкруглитьПериод(ДатаНачалаПериода, Минута(ДатаНачалаПериода) / СекундВМинуте, Коэффициент))/СекундВЧасе - Дней * ЧасовВДне; //Костенюк Александр 30.06.2016
	Иначе
		// -- По числам.
		Дней = ДатаНачалаПериода;
		Часов = ДатаОкончанияПериода;
		Продолжительность = Дней * СекундВДне + Часов * СекундВЧасе;
	КонецЕсли;
	
	// Результат.
	Возврат СтрЗаменить(СокрЛ(Формат(Дней) + " " + Формат(Цел(Часов), "ЧЦ=2; ЧН=; ЧВН=") + ":" + Формат(Цел((Часов - Цел(Часов)) * МинутВЧасе), "ЧЦ=2; ЧН=; ЧВН=")), " ", "+");
	
КонецФункции

//Костенюк Александр-Старт 30.06.2016
Функция ОкруглитьПериод(Период, Коэффициент, КоэффициентОкругления) Экспорт
	
	МинутВЧасе = 60;
	СекундВМинуте = 60;
	
	Если Коэффициент > КоэффициентОкругления Тогда
		Если Коэффициент > 3*КоэффициентОкругления Тогда
			Возврат НачалоЧаса(Период) + (МинутВЧасе * СекундВМинуте); 										// 09.52 => 52/60 = 0.87
		ИначеЕсли ((Коэффициент > КоэффициентОкругления) И (Коэффициент <= 2*КоэффициентОкругления))        // 09.23 => 23/60 = 0.38
			ИЛИ	((Коэффициент > 2*КоэффициентОкругления) И (Коэффициент <= 3*КоэффициентОкругления)) Тогда  // 09.41 => 41/60 = 0.68
			Возврат НачалоЧаса(Период) + (0.5 * МинутВЧасе * СекундВМинуте); 													 
		КонецЕсли;
	Иначе
		Возврат НачалоЧаса(Период); 																		// 09.13 => 13/60 = 0.21
	КонецЕсли;
	
КонецФункции
//Костенюк Александр-Финиш 30.06.2016


// Очистка рег. сведений перед записью новыми значениями
//
Процедура ОчиститьРегистрСведений(ЗначРегистра) Экспорт
	НаборЗаписей = РегистрыСведений[ЗначРегистра].СоздатьНаборЗаписей();
	НаборЗаписей.Очистить();
	НаборЗаписей.Записать();	
КонецПроцедуры


Функция ПолучитьЧисло(Значение = Неопределено) Экспорт
			
	ТипЗначения = ТипЗнч(Значение);
	
	// Дата.
	Если (ТипЗначения = Тип("Дата")) Тогда
		Возврат Значение - '00010101000000';
	КонецЕсли;
	
	// Число.
	Если (ТипЗначения = Тип("Число")) Тогда
		Возврат Значение;
	КонецЕсли;
	
	// Произвольный тип.
	Строкой = Строка(Значение); НормализованнойСтрокой = Строка(Неопределено);
	НайденаЦифра = Ложь; НайденМинус = Ложь; НайденаЗапятая = Ложь;
	
	Индекс = 1; Длина = СтрДлина(Строкой); КодПредидущего = 0; КодПредпредидущего = 0;
	Пока (Индекс <= Длина) Цикл
		Символ = Сред(Строкой, Индекс, 1); Код = КодСимвола(Символ);
		
		Если (Код >= 48) И (Код <= 57) Тогда
			// Минус.
			Если (КодПредидущего = 45) Тогда
				НормализованнойСтрокой = НормализованнойСтрокой + "-"; НайденМинус = Истина;
			КонецЕсли;
			// Запятая.
			Если (КодПредидущего = 44) Или (КодПредидущего = 46) Тогда
				Если (КодПредпредидущего = 45) Тогда
					НормализованнойСтрокой = НормализованнойСтрокой + "-"; НайденМинус = Истина;
				КонецЕсли;
				Если Не НайденаЦифра Тогда
					НормализованнойСтрокой = НормализованнойСтрокой + "0";
				КонецЕсли;
				НормализованнойСтрокой = НормализованнойСтрокой + "."; НайденаЗапятая = Истина;
			КонецЕсли;
			// Числа.
			НормализованнойСтрокой = НормализованнойСтрокой + Символ; НайденаЦифра = Истина;
		Иначе
			Если (Код = 44) Или (Код = 46) Тогда
				// Запятая.
				Если НайденаЗапятая Тогда
					Прервать;
				КонецЕсли;
			ИначеЕсли (Код = 45) Тогда
				// Минус.
				Если НайденМинус Тогда
					Прервать;
				КонецЕсли;
			ИначеЕсли (Код = 32) Тогда
				// Пробел.
				Если НайденаЦифра И (КодПредидущего = 32) Тогда
					Прервать;
				КонецЕсли;
			Иначе
				// Символы.
				Если НайденаЦифра Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		КодПредпредидущего = КодПредидущего; КодПредидущего = Код;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если ПустаяСтрока(НормализованнойСтрокой) Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат Число(НормализованнойСтрокой);
	
КонецФункции // ПолучитьЧисло()

Функция ПолучитьВремя(Значение = Неопределено) Экспорт
	
	Возврат '00010101000000' + (Значение - НачалоДня(Значение));
	
КонецФункции


Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить


Функция ПредставлениеСправочникаДляЗаголовкаСообщения(Ссылка) Экспорт
	
	Представление = СокрЛП(Ссылка);
	
	Если ПустаяСтрока(Представление) Или (Представление = "<>") Тогда
		Представление = Ссылка.Метаданные().Синоним;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции // ПредставлениеСправочник()


Функция УстановитьРеквизитОбъекта(Объект, Реквизит, Значение) Экспорт
	
	Объект[Реквизит] = Значение;	
	
	Возврат Истина;
	
КонецФункции // УстановитьРеквизитОбъекта()

Функция УстановитьИПроверитьРеквизитОбъекта(Объект, Реквизит, Значение) Экспорт
	
	Попытка
		Объект[Реквизит] = Значение;	
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Возврат (Объект[Реквизит] = Значение);
	
КонецФункции // УстановитьИПроверитьРеквизитОбъекта()


// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта, КодЯзыка = "ru") Экспорт

	ПараметрыПрописи = Локализация.ПараметрыПрописи(Валюта, КодЯзыка); 
	Если ПараметрыПрописи = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма,"Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка),ПараметрыПрописи);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()


// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено, ИспользоватьНомераСокращенные = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Если (ИспользоватьНомераСокращенные = Неопределено) Тогда
		ИспользоватьНомераСокращенные = (УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "ПечатьИспользоватьНомераСокращенные") = Истина);
	КонецЕсли;
	
	Номер   = СокрЛП(Документ.Номер);
	
	Если ИспользоватьНомераСокращенные Тогда
		СтруктруаИзвлечения = Новый Структура("НомерСокращенный");
		ЗаполнитьЗначенияСвойств(СтруктруаИзвлечения, Документ);
		Если ПустаяСтрока(СтруктруаИзвлечения.НомерСокращенный) Тогда
			ИспользоватьНомераСокращенные = Ложь;
		Иначе
			Номер = СтруктруаИзвлечения.НомерСокращенный;
		КонецЕсли;
	КонецЕсли;
	
	Префикс = "";
	ПрефиксДоверенности = "";
	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда

		//Если ЗначениеЗаполнено(Документ.Организация) Тогда
		//	Префикс = СокрЛП(Документ.Организация.Префикс);
		//КонецЕсли;

	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда

		Если Документ.Свойство("Префикс") Тогда
			Префикс = СокрЛП(Документ.Префикс);
			
		Иначе
			//Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;

	Иначе

		МетаданныеДокумента = Документ.Метаданные();

		Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

			Если ЗначениеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;

		КонецЕсли;
		
		Если МетаданныеДокумента.Имя = "Доверенность" Тогда
			ПрефиксДоверенности = "Д";
		КонецЕсли;
		
	КонецЕсли;
	
	ПрефиксУзла = "";
	//ДобавитьПрефиксУзла(ПрефиксУзла);
	
	СписокПрефиксов = Новый СписокЗначений();
	Если ПрефиксУзла <> "" Тогда
		СписокПрефиксов.Добавить(ПрефиксУзла);
	КонецЕсли;	
	Если Префикс <> "" Тогда
		СписокПрефиксов.Добавить(Префикс);
	КонецЕсли;
	
	Если ПрефиксДоверенности <> "" Тогда
		СписокПрефиксов.Добавить(ПрефиксДоверенности);
	КонецЕсли;
	
	Если СписокПрефиксов.Количество() = 0 Тогда
		СписокПрефиксов.Добавить("");
	КонецЕсли;

	Для Каждого ЭлементСписка ИЗ СписокПрефиксов Цикл
		
		ТекущийПрефикс = ЭлементСписка.Значение;
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Если Не ИспользоватьНомераСокращенные Тогда
			Пока Лев(Номер, 1)="0" Цикл
				Номер = Сред(Номер, 2);
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "", КодЯзыка = "ru", Кртатко = Ложь, ИспользоватьНомераСокращенные = Неопределено) Экспорт

	Если КодЯзыка = Неопределено Тогда 
		КодЯзыка = Локализация.ПолучитьЯзыкФормированияПечатныхФорм(УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "РежимФормированияПечатныхФорм"));
	КонецЕсли;
	
	Если Кртатко Тогда
		Возврат Строка(НазваниеДокумента) + " № " + ПолучитьНомерНаПечать(ДокументОбъект, , ИспользоватьНомераСокращенные) +
					НСтр("ru=' от ';uk=' від '",КодЯзыка) + Формат(ДокументОбъект.Дата, "Л=; ДЛФ=D") + НСтр("ru=' г.';uk=' р.'",КодЯзыка);
	КонецЕсли;
	
	Возврат Строка(НазваниеДокумента) + " № " + ПолучитьНомерНаПечать(ДокументОбъект, , ИспользоватьНомераСокращенные) +
				НСтр("ru=' от ';uk=' від '",КодЯзыка) + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг';Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)) + НСтр("ru=' г.';uk=' р.'",КодЯзыка);

КонецФункции // СформироватьЗаголовокДокумента()


#Если Клиент Тогда
	
// Показывает таблицу значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьТаблицуЗначений(ТЗ, Заголовок = "") Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьТаблицуЗначений(ТЗ, Заголовок);
КонецПроцедуры // ПоказатьТаблицуЗначений(ТЗ)

// Показывает дерево значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьДеревоЗначений(ДЗ, Заголовок = "") Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьДеревоЗначений(ДЗ, Заголовок);
КонецПроцедуры // ПоказатьДеревоЗначений(ТЗ)

#КонецЕсли


// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Дополняет передаваемую строку Строка символами Символ до строки длиной Длина слева
//
// Параметры:
//  Строка       - строка, к которой надо добавить символы
//  Символ       - добавляемый символ
//  Длина        - длина результирующей строки
//
// Возвращаемое значение:
//  строка
//
Функция ДополнитьСтрокуЛ(Строка, Символ, Длина) Экспорт

	Добавить = Длина - СтрДлина(Строка);
	ВозвращаемаяСтрока = Строка;
	Для а = 1 По Добавить Цикл
		ВозвращаемаяСтрока = Символ + ВозвращаемаяСтрока;
	КонецЦикла;

	Возврат ВозвращаемаяСтрока;

КонецФункции // ДополнитьСтрокуЛ()

#Если Клиент Тогда

Функция ЗагрузитьКомпоненту(ИмяФайла, Компонента = Неопределено) Экспорт
//СтрокаСоединенияИнформационнойБазы()	
	
	// Поиск компоненты.
	МассивПутей = Новый Массив;
	МассивПутей.Добавить(КаталогПрограммы());
//	МассивПутей.Добавить("%PROGRAMFILES%");
	МассивПутей.Добавить("%SYSTEMROOT%\System32");
	МассивПутей.Добавить("%SYSTEMROOT%");
	
	Для Каждого Путь Из МассивПутей Цикл
		Файл = Новый Файл(Путь + "\" + ИмяФайла);
		Если Файл.Существует() Тогда
			Прервать;
		КонецЕсли;
        Файл = Неопределено;
	КонецЦикла;
	Если (Файл = Неопределено) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Загрузка.
	Попытка
		ЗагрузитьВнешнююКомпоненту(Файл.ПолноеИмя);
	Исключение
		Попытка
			Если (Не Компонента = Неопределено) Тогда
				ПодключитьВнешнююКомпоненту(Компонента);
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецПопытки;
	
	// Создание компоненты.
	Если (Не Компонента = Неопределено) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Возврат Новый (Компонента);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции // ЗагрузитьКомпоненту()

 #КонецЕсли

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();
	Возврат МетаданныеДокумента;

КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()
      

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции

 // Функция выделяет первое слово в предложении
Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
//
// Параметры
//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
//
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет		= 0;
	Месяцев	= 0;
	Дней	= 0;
	Если Дата1 > Дата2 Тогда
		
		ВременнаяДата = Дата1;
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
		КонецЕсли;
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
			Месяцев = 12;
		КонецЕсли;
		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
		
		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
			Дней = Дней + (День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры	// РазобратьРазностьДат
               
// ПолучитьРазностьДат как в запросе
Функция ПолучитьРазностьДат(ДатаНачало, ДатаКонец, Параметр = Неопределено) Экспорт 
	
	Запрос = Новый Запрос;	
	Запрос.Текст = "ВЫБРАТЬ
	               |	РАЗНОСТЬДАТ(Запрос.ДатаНачало, Запрос.ДатаКонец, СЕКУНДА) КАК ЗначениеРезультат
	               |ИЗ
	               |	(ВЫБРАТЬ
	               |		&ДатаНачало КАК ДатаНачало,
	               |		&ДатаКонец КАК ДатаКонец) КАК Запрос";
	
	Если не Параметр = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "РАЗНОСТЬДАТ(Запрос.ДатаНачало, Запрос.ДатаКонец, СЕКУНДА) КАК ЗначениеРезультат" , "РАЗНОСТЬДАТ(Запрос.ДатаНачало, Запрос.ДатаКонец, "+Параметр+ ") КАК ЗначениеРезультат" );
	КонецЕсли;	
	Запрос.УстановитьПараметр("ДатаНачало", ДатаНачало);
	Запрос.УстановитьПараметр("ДатаКонец", ДатаКонец);	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЗначениеРезультат;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	ЕстьПериод    = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					Если не ЗаполнитьПериод и ЕстьПериод И НЕ СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					Иначе
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					КонецЕсли; 
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);
	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции	// ПолучитьОписаниеТиповДаты() 


// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина, РаспрСумма=0) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач   = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма    = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	//Если после распределения остались копейки (типа, после распределения 100 стало 99,99 или 100,01)
	//то выравниваем эти суммы на последнем элементе	
	РаспрСумма = ИсхСумма;	
		
	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()


// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции


Функция ПолучитьСтруктуруКолонок(Колонки) Экспорт

	Результат = Новый Структура;
	
	Для Каждого Колонка Из Колонки Цикл
		Результат.Вставить(Колонка.Имя);	
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ПолучитьСтруктуруКолонок()



// Функция возвращает либо переданную дату, либубо текущую если переданное значение не заполнено.
//
Функция ПолучитьНеПустуюДату(Значение, Алетернатива = Неопределено) Экспорт
	
	Если ОбщегоНазначения.ЗначениеНЕЗаполнено(Значение) Тогда
		Если (Алетернатива = Неопределено) Тогда
			Возврат ТекущаяДата();
		Иначе
			Возврат Алетернатива;
		КонецЕсли;
	КонецЕсли;
		
	Возврат Значение;
	
КонецФункции // ПолучитьНеПустуюДату()


Функция ПолучитьБулевоеСвойство(Структура, Свойство) Экспорт
	
	Перем Значение;
	
	Если Структура.Свойство(Свойство, Значение) Тогда
		Возврат Значение;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // ПолучитьСвойство()

Функция ОбъеденитьСтруктуры(Первая, Вторая, Получатель = Неопределено) Экспорт
	
	Если (Получатель = Неопределено) Тогда
		Получатель = Новый Структура;
	КонецЕсли;
	
	Для Каждого ЭлементСтруктуры Из Первая Цикл
		Получатель.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);	
	КонецЦикла;
	
	Для Каждого ЭлементСтруктуры Из Вторая Цикл
		Получатель.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);	
	КонецЦикла;
	
	Возврат Получатель;
	
КонецФункции


Функция СокрЛСП(Строка) Экспорт
	
	Результат = СокрЛП(Строка);
	
	Пока Булево(Найти(Результат, "  ")) Цикл
		Результат = СтрЗаменить(Результат, "  ", " ");	
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции // СокрЛСП()


Функция РежимFrontOffice() Экспорт
	
	#Если Клиент Тогда
		
		Возврат (Не глСерверFrontOffice = Неопределено);
		
	#Иначе
			
		Возврат Ложь;

	#КонецЕсли
	
КонецФункции // РежимFrontOffice()

//Костенюк Александр-Старт 05.07.2012
//
// Функция возвращает время в часах, минутах, секундах
//
// Параметры
// Секунд - Тип: Число, кол-во секунд
//
// Возвращаемое значение:
// Тип: Строка
// 
Функция ЧЧММСС(Секунд) Экспорт
	Часов = 0;
	Минут = 0;
	СтрокаВозврата = "";
	Если Секунд >= 60*60 Тогда
		Часов = Цел(Секунд / (60*60));
		Секунд = Секунд % (60*60);
		СтрокаВозврата = " "+Часов+" ч";
	КонецЕсли; 
	Если Секунд >= 60 Тогда
		Минут = Цел(Секунд / 60);
		Секунд = Секунд % 60;
		СтрокаВозврата = СтрокаВозврата+" "+Минут+" м";
	КонецЕсли;
	СтрокаВозврата = СтрокаВозврата+" "+Секунд+" с";
	Возврат СтрокаВозврата;
КонецФункции 
//Костенюк Александр-Финиш 05.07.2012

//Костенюк Александр-Старт 10.06.2013
// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()
//Костенюк Александр-Финиш 10.06.2013


//Дима
//

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  Структура с полями 
//   ИмяТаблицы - Строка
//   Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - коллекция, отвечающая вышеописанным требованиям
//	КоллекцияСтрок2 - коллекция, отвечающая вышеописанным требованиям
//	ИменаКолонок 	- строка, разделенная запятыми - имена колонок, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки	- имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - булево, если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;

	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
						СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
						
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
	
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура.
//          - Соответствие, ФиксированноеСоответствие.
//          - Массив,       ФиксированныйМассив.
//          - ХранилищеЗначения, ТаблицаЗначений.
//          - Простые типы, которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции
//Костенюк Александр-Финиш 10.06.2013




////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Фиксирует Данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Коллекция;
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект
//  Объект - ОбъектXDTO - объект, копию которого требуется создать
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, а Значение - структура, которая 
//				содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными
//				из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, Значение - значение прочитанного реквизита
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В(&МассивДокументов)
		|	И НЕ ПсевдонимЗаданнойТаблицы.Проведен";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		МетаданныеДокумента = Документ.Метаданные();
		Если ИменаДокументов.Найти(МетаданныеДокумента.ПолноеИмя()) = Неопределено
			И Метаданные.Документы.Содержит(МетаданныеДокумента)
			И МетаданныеДокумента.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				ИменаДокументов.Добавить(МетаданныеДокумента.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//									Ссылка         - документ, который не удалось провести;
//									ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Проведение документов при печати'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Информация, ДокументОбъект.Метаданные(), ДокументСсылка, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 


////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления"
//
// Тип: Строка
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности"
//
// Тип: Строка
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания"
//
// Тип: Строка
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 


// Возвращает Истина, если текущий сеанс выполняется на сервере, работающим под управлением ОС Linux.
//
// Возвращаемое значение:
//  (Булево) Истина, если сервер работает под управлением ОС Linux.
//
Функция ЭтоLinuxСервер() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

// Возвращает Истина при необходимости обновления конфигурации информационной базы подчиненного узла РИБ.
// В главном узле всегда - Ложь.
//
Функция ТребуетсяОбновлениеКонфигурацииПодчиненногоУзлаРИБ() Экспорт
	
	Возврат ЭтоПодчиненныйУзелРИБ() И КонфигурацияИзменена();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
//                                                     то подробное описание ошибки помещается в этот параметр
//
// Возвращаемое значение:
//  Тип: COM-объект, Неопределенно.
//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//  в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
// Возвращаемое значение - структура:
//  Соединение                  - (COM-объект) указатель на COM-объект соединения или Неопределено в случае ошибки
//  КраткоеОписаниеОшибки       - (Строка) краткое описание ошибки
//  ПодробноеОписаниеОшибки     - (Строка) подробное описание ошибки
//  ОшибкаПодключенияКомпоненты - (Булево) флаг ошибки подключения COM
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь);
	
	Если ЭтоLinuxСервер() Тогда
		Результат.Соединение = Неопределено;
		Результат.ПодробноеОписаниеОшибки = НСтр("ru = 'Прямое подключение к информационной базе недоступно на сервере под управлением ОС Linux.'");
		Результат.КраткоеОписаниеОшибки = Результат.ПодробноеОписаниеОшибки;
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V82.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

// Проверяет, включена ли регистрация событий УровниСобытий в журнале регистрации.
//
// Параметры: 
//   УровниСобытий - СписокЗначений - список строк с уровнями регистрации событий журнала регистрации, 
//                                    для которых необходимо проверить, что они включены.
//                                    Если Неопределено, то проверяются все уровни событий.
//
// Возвращаемое значение: 
//   Булево - Истина, когда заданные режимы включены. Иначе - Ложь.
//
Функция ПроверитьВключениеЖурналаРегистрации(УровниСобытий = Неопределено) Экспорт	
	
	УстановленныеУровниСобытий = ПолучитьИспользованиеЖурналаРегистрации();
	Если УровниСобытий = Неопределено Тогда
		Возврат УстановленныеУровниСобытий.Количество() = 4; // включены все уровни событий?
	КонецЕсли;
	
	ИменаУровнейСобытий = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УровниСобытий);
	Для Каждого Название Из ИменаУровнейСобытий Цикл
		УровеньСобытия = УровеньСобытияПоПредставлению(Название);
		Если УстановленныеУровниСобытий.Найти(УровеньСобытия) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// Значение – Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
// XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML – строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(
			Знач АдресWSDL,
			Знач URIПространстваИмен,
			Знач ИмяСервиса,
			Знач ИмяТочкиПодключения = "",
			Знач ИмяПользователя,
			Знач Пароль,
			Знач Таймаут = Неопределено,
			Знач ДелатьКонтрольныйВызов = Ложь
	) Экспорт
	
	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на получение wsdl
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	
	Если Ложь Тогда  // ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета")
		ДоступноПолучениеФайловИзИнтернета = Истина;
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(АдресWSDL);
	Параметры.Добавить(ИмяПользователя);
	Параметры.Добавить(Пароль);
	Параметры.Добавить(Таймаут);
	
	Возврат Новый(Тип("WSОпределения"), Параметры);
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль,
	Знач Таймаут = Неопределено) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(WSОпределения);
	Параметры.Добавить(URIПространстваИмен);
	Параметры.Добавить(ИмяСервиса);
	Параметры.Добавить(ИмяТочкиПодключения);
	Параметры.Добавить(Таймаут);
	
	Прокси = Новый(Тип("WSПрокси"), Параметры);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() = 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ  = ЧастиИмени[1];
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Если ЧастиИмени.Количество() = 2 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда
				// Перерасчет
				Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Попытка
			Возврат Менеджер[ИмяОМ];
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.2.17.153");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь);
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	ОбщиеПараметры.Вставить("ОтключитьСправочникИдентификаторыОбъектовМетаданных", Ложь);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек(ОбщиеПараметры.ИмяФормыПерсональныхНастроек);
	ОбщегоНазначенияВызовСервераПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Проверяет имя экспортной процедуры на валидность для использования
// в инструкции Выполнить встроенного языка. При некорректном имени
// вызывается исключение.
//
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
//
// Параметры:
// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
// 							  реквизит заполняется значениями из второго параметра процедуры.
// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - СписокЗначений, клиентская глобальная переменная
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор
//
// Возвращаемое значение:
//  Структура
//		Ключ - имя константы из набора
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
